
====================
// ARQUIVO: .\main.cpp
====================
#include "application/LibService.h"

#include "infra/db/sqlite_database.h"
#include "infra/db/init.h"
#include "infra/db/update.h"
#include "infra/repositories/UserRepository.h"
#include "infra/repositories/BookRepository.h"
#include "infra/repositories/ItemRepository.h"
#include "infra/repositories/LoanRepository.h"
#include "infra/repositories/SearchRepository.h"

#include "ui/terminal/configurarTerminal.h"
#include "ui/utils/exibirSelecao.h"
#include "ui/controller/MenuPrincipal.h"

#include <iostream>



int main() {
    configurarTerminal();

    SqliteDatabase db("biblioteca.db");

    auto init = dbInitializer::criarTabelas(db);
   
    if (!init) {
        std::cout << "Erro na criação de tabelas: " << init.error().message << std::endl;
        system("pause");
        return 1;
    }
     
    auto up = updateDb(db);

    if (!up) {
        std::cout << "Erro na atualização de tabelas: " << up.error().message << std::endl;
        system("pause");
        return 1;
    }

    UserRepository users(db);
    BookRepository books(db);
    ItemRepository items(db);
    LoanRepository loans(db);
    SearchRepository searches(db);
    ReservaRepository reserva(db);

    LibService serv(db, users, books, items, loans, searches, reserva);

    MenuPrincipal(serv);

}



====================
// ARQUIVO: .\application\LibService.cpp
====================
#include "LibService.h"

#include "../core/utils/TimeUtils.h"


LibService::LibService(
    Database& db,
    UserRepository& users,
    BookRepository& books,
    ItemRepository& items,
    LoanRepository& loans,
    SearchRepository& searches,
    ReservaRepository& reserva
    ) : db(db), users(users), books(books), items(items), loans(loans), searches(searches), reserva(reserva) {}


Error LibService::handleRollback ( Error erroOriginal ) {
    auto rb = db.rollback ( );
    if ( !rb ) {
        return addContext ( erroOriginal, "Erro crítico: Falha ao interromper transação. " );
    }
    return  addContext ( erroOriginal, "Transação interrompida: " );
}

ECM::Result LibService::checkBlock(const UserId id_user) {
    // 1. Buscando o status do usuário
    auto check = users.getUserState(id_user);
    if (!check) {
        return std::unexpected(addContext(check.error(),
            "Não foi possível verificar bloqueio: "));
    }
    UserState state = check.value();
    // 2. Verificando se ele se encontra bloqueado ou inativo
    if (state.status == UserStatus::Bloqueado) {
        if (!state.blocked_until)
            return std::unexpected(blocked());
        return std::unexpected(blocked(state.blocked_until.value()));
    }
    if (state.status == UserStatus::Inativo) {
        return std::unexpected(inactive());
    }
    return {};
}

ECM::Result LibService::checkBlock(const UserState state) {
    if (state.status == UserStatus::Bloqueado) {
        if (!state.blocked_until)
            return std::unexpected(blocked());
        return std::unexpected(blocked(state.blocked_until.value()));
    }
    if (state.status == UserStatus::Inativo) {
        return std::unexpected(inactive());
    }
    return {};
}

ECM::Result LibService::checkLimit(const UserId& id_user) {
    auto nLoanTest = loans.ativosPorUser(id_user);
    if (!nLoanTest) {
        return std::unexpected(addContext(nLoanTest.error(), "Não foi possível verificar o número de empréstimos ativos deste usuário"));
    }
    auto nReservTest = reserva.ativasPorUser(id_user);
    if (!nReservTest) {
        return std::unexpected(addContext(nReservTest.error(), "Não foi possível verificar o número de reservas ativas deste usuário"));
    }
    if (nLoanTest.value() + nReservTest.value() > 3) {
        return std::unexpected(forbidden("Usuário excedeu o limite de empréstimos/reservas ativas"));
    }
    return {};
}

ECM::Result LibService::meetCriteria(const UserId& id_user){
    // 1. Buscando o status do usuário
    auto res = users.getUserState(id_user);
    if (!res) {
        return std::unexpected(addContext(res.error(),
            "Não foi possível verificar o status do usuário: "));
    }
    UserState state = res.value();
    // 2. Verificando se ele se encontra bloqueado ou inativo
    auto check = checkBlock(state);
    if (!check) {
        return std::unexpected(check.error());
    }

    //3. Verificando se o usuário excedeu o limite de empréstimos + reservas ativas
    auto check_limit = LibService::checkLimit(id_user);
    if (!check_limit) {
        return std::unexpected(check_limit.error());
    }

    return {};
}

ECM::Result LibService::cadastrarLivro(const Book& livro) {
    
    auto res = db.begin();
    if (!res) return std::unexpected(addContext(res.error(), "Erro ao iniciar a transação: "));

    
    res = books.salvar(livro);
    if (!res) return std::unexpected(handleRollback(addContext(res.error(), "Erro ao salvar livro: ")));

    
    res = items.salvar(livro, 0, livro.copias);
    if (!res) return std::unexpected(handleRollback(addContext(res.error(), "Erro ao salvar item: ")));

    
    res = db.commit();
    if (!res) return std::unexpected(addContext(res.error(), "Erro ao finalizar a transação: "));

    return {};
}

ECM::Result LibService::salvarUsuario(const User& u) {
    return users.salvar(u);
}

ECM::Result LibService::adicionarItem(const BookId& id, int n) {

    auto res = books.getBook(id);
    if (!res) {
        return std::unexpected(addContext(res.error(), "Não foi possível adicionar os itens extras pois não foi possível recuperar o livro desejado pelo Id: "));
    }
    auto nTest = items.maxId(id);
    if (!nTest) {
        return std::unexpected(nTest.error());
    }
    int n_Ex = nTest.value();
    auto bg = db.begin();
    if (!bg) return std::unexpected(addContext(bg.error(), "Erro ao iniciar a transação: "));

    auto result = items.salvar(res.value(), n_Ex, n);
    if (!result) return std::unexpected(handleRollback(addContext(result.error(), "Erro ao salvar item: ")));


    auto Commit = db.commit();
    if (!Commit) return std::unexpected(addContext(Commit.error(), "Erro ao finalizar a transação: "));

    return {};

}

ECM::Expected<std::vector<BookSearchResult>>
LibService::buscarLivros(std::string_view term, BookSearchField field) {

    if (term.empty())
        return std::unexpected(validation("Não foi possível realizar a busca: palavra-chave vazia."));

    auto res = searches.searchBooks(term, field);

    if (!res)
        return std::unexpected(addContext(res.error(), "Erro ao realizar busca: "));

    if (res->empty())
        return std::unexpected(notFound("Nenhum livro encontrado."));


    return res.value();
}

ECM::Expected<std::vector<ReservaInfo>> LibService::buscarReservas(const UserId& id) {
    auto res = reserva.listarAtivasPorUser(id);

    if (!res)
        return std::unexpected(addContext(res.error(), "Erro ao realizar busca: "));

    if (res->empty())
        return std::unexpected(notFound("Nenhuma reserva encontrada."));


    return res.value();
}

ECM::Expected<std::vector<UserSearchResult>> LibService::buscarUsuario(std::string_view term) {
    if (term.empty())
        return std::unexpected(validation("Não foi possível realizar a busca: palavra-chave vazia."));

    auto res = searches.searchUser(term);

    if (!res)
        return std::unexpected(addContext(res.error(), "Erro ao realizar busca: "));

    if (res->empty())
        return std::unexpected(notFound("Nenhum usuário encontrado."));

    return res.value();
}

ECM::Expected<std::vector<UserSearchResult>> LibService::buscarUsuarioId(const UserId& id) {

    auto res = searches.searchUser(id.get_Id_int());

    if (!res)
        return std::unexpected(addContext(res.error(), "Erro ao realizar busca: "));

    if (res->empty())
        return std::unexpected(notFound("Nenhum usuário encontrado."));

    return res.value();
}

ECM::Expected<User> LibService::idToUser(const UserId& id) {
    auto res = users.getUser(id);
    if (!res) {
        return std::unexpected(addContext(res.error(), "Não foi possível encontrar o usuário: "));
    }
    return res.value();
}

ECM::Result LibService::alterarUsuario(const User& u) {
    return users.update(u);
}

ECM::Result LibService::cancelarReserva(int id) {

    auto res = reserva.updateStatus(id, ReservaStatus::Cancelada);

    if (!res) {
        return std::unexpected(addContext(res.error(), "Não foi possível cancelar a reserva: "));
    }

    return {};
}

ECM::Expected<std::chrono::year_month_day> LibService::preverDisponibilidade(const BookId& book){
    //1. buscando o vetor de datas previstas das devoluções
    auto test = loans.datasPrevistasPorLivro(book);
    if (!test) {
        return std::unexpected(addContext(test.error(), "Não foi possível prever data de disponibilidade: "));
    }
    auto datas = test.value();
    if (datas.empty()) {
        return std::unexpected(conflict("Não foi possível efetivar a reserva: há itens disponíveis deste título!"));
    }

    //2. buscando o número de reservas ativas do livro
    auto test2 = reserva.ativasPorLivro(book);
    if (!test2) {
        return std::unexpected(addContext(test.error(), "Não foi possível prever data de disponibilidade: "));
    }
    int ativas = test2.value();
   
    //3. buscando o número total de itens
    auto test3 = items.quantosLivros(book);
    if (!test3) {
        return std::unexpected(addContext(test.error(), "Não foi possível prever data de disponibilidade: "));
    }
    int tot = test3.value();

    //4. fazendo a previsão
    if (ativas >= tot) {
        return std::unexpected(unknown("Não foi possível prever data de disponibilidade (número de reservas maior que o número de itens)"));
    }
    else {
        return std::chrono::sys_days(datas[ativas]);
    }
}

ECM::Expected<Loan> LibService::emprestar(const UserId& id_user, const ItemId& id_item) {

    // 1. Buscando o status do usuário
    auto res = users.getUserState(id_user);
    if (!res) {
        return std::unexpected(addContext(res.error(), 
        "Não foi possível realizar o empréstimo pois não foi possível verificar o status do usuário: "));
    }
    UserState state = res.value();
    // 2. Verificando se ele se encontra bloqueado ou inativo
    auto check = checkBlock(state);
    if (!check) {
        return std::unexpected(addContext(check.error(),
            "Não foi possível realizar o empréstimo: "));
    }

    //3. Verificando se o usuário excedeu o limite de empréstimos + reservas ativas
    auto check_limit = LibService::checkLimit(id_user);
    if (!check_limit) {
        return std::unexpected(check_limit.error());
    }
 
        //4. Verificando se o item existe
        auto check_item = items.buscarId(id_item);
        if (!check_item) {
            return std::unexpected(addContext(check_item.error(), "Não foi possível realizar o empréstimo: "));
        }
        //5. Verificando se o item possui reserva ativa
        auto checkReserva = reserva.proximaReserva(id_item.getBook());

        if (!checkReserva && (checkReserva.error().type != Error::Type::NotFound)) {
            return std::unexpected(checkReserva.error());
        }
        ReservaInfo info;

        if (checkReserva) {
            info = checkReserva.value();
            // 6. checando se a reserva está no nome de quem está realizando o empréstimo
            if (info.id_user != id_user.get_Id_int()) {
                // 7. retornar informação da reserva
                return std::unexpected(reserved(info.nome_user));
            }
        }
        //8. Calculando prazo e construindo objeto loan
        std::chrono::year_month_day loaned = today();
        std::chrono::year_month_day due = std::chrono::sys_days(loaned) + prazoPerRole(state.role);
        Loan l(0, id_item, id_user, loaned, due);

        //9. Iniciando transação
        
        auto res_begin = db.begin ( );
        if ( !res_begin ) return std::unexpected ( addContext ( res.error ( ), "Erro ao iniciar a transação: " ) );

        //9. Salvando empréstimo
        auto res_salvar = loans.salvar(l);
        if (!res_salvar) {
            return std::unexpected(handleRollback ( addContext ( res_salvar.error ( ), "Não foi possível registrar o empréstimo: " ) ));
            return std::unexpected(addContext(res_salvar.error(), "Não foi possível registrar o empréstimo: "));
        }

        //10. Alterando status da reserva
        if (checkReserva) {
            auto update_reserva = reserva.updateStatus(info.id_reserva, ReservaStatus::Atendida);
            if (!update_reserva) {
                return std::unexpected(handleRollback ( addContext ( update_reserva.error ( ), "Não foi possível efetivar a reserva!: " ) ));
                return std::unexpected(addContext(update_reserva.error(), "Não foi possível efetivar a reserva!"));
            }
        }

        auto res_commit = db.commit ( );
        if ( !res ) return std::unexpected ( addContext ( res_commit.error ( ), "Erro ao finalizar a transação: " ) );

        return l;
}

ECM::Result LibService::devolver(const UserId& user, const ItemId& item) {

    // 1. Buscando o status do empréstimo
    auto loanState = loans.getLoanState(user, item);
    if (!loanState) {
        return std::unexpected(addContext(loanState.error(),
            "Não foi possível localizar o empréstimo: "));
    }

    LoanState state = loanState.value();

    // 2. Verificando o status
    if (state.status == LoanStatus::Devolvido) {
        return std::unexpected(conflict("Este item já foi devolvido."));
    }

    // 3. Registrando devolução
    auto resDev = loans.realizarDevolucao(state.loan_id);
    if (!resDev) {
        return std::unexpected(addContext(resDev.error(),
            "Não foi possível registrar a devolução: "));
    }

    // 4. Verificando atraso
    auto hoje = today();
    auto atraso = std::chrono::sys_days(hoje) - std::chrono::sys_days(state.due_at);

    if (atraso > std::chrono::days{ 0 }) {

        // 5. Bloqueia usuário
        auto resBlock = users.block(user, atraso);
        if (!resBlock) {
            return std::unexpected(addContext(resBlock.error(),
                "Devolução realizada com sucesso, mas falha ao bloquear usuário: "));
            // TODO: resolver a questão que, nesse caso, o sistema retorna e não checa se o livro tem reserva ativa
            
        }

        // 6. Retorna dados de bloqueio
        return std::unexpected(checkBlock(user).error());
    }

    // 7. checa se existe reserva ativa com este título
    auto checkReserva = reserva.proximaReserva(item.getBook());

    if (!checkReserva && (checkReserva.error().type != Error::Type::NotFound)) {
        return std::unexpected(checkReserva.error());
    }

    
    if (checkReserva) {
        //std::cout << "Deu bom a reserva" << std::endl;
        ReservaInfo info = checkReserva.value();
        // 8. mudar status da reserva
        auto res_update = reserva.updateStatus(info.id_reserva, ReservaStatus::AguardandoRetirada);
        // 9. retornar informação da reserva
        return std::unexpected(reserved(info.nome_user));
    }

    // 9. Sucesso total
    return {};
}

ECM::Result LibService::renovar(const UserId& user, const ItemId& item) {

    constexpr int LIMITE_RENOVACOES = 3;
    constexpr int PRAZO_DIAS = 14;

    // 1. Buscando o status do empréstimo
    auto loanState = loans.getLoanState(user, item);
    if (!loanState) {
        return std::unexpected(addContext(loanState.error(),
            "Não foi possível localizar o empréstimo: "));
    }

    LoanState state = loanState.value();

    // 2. Validando status do empréstimo
    if (state.status == LoanStatus::Devolvido) {
        return std::unexpected(validation("Este item já foi devolvido."));
    }

    // 3. Verificando atraso 
    auto hoje = today();
    auto atraso = std::chrono::sys_days(hoje) - std::chrono::sys_days(state.due_at);

    if (atraso > std::chrono::days{ 0 }) {

        // 3.1 Bloqueia usuário
        auto resBlock = users.block(user, atraso);
        if (!resBlock) {
            return std::unexpected(addContext(resBlock.error(),
                "Empréstimo em atraso, mas falha ao bloquear usuário: "));
        }

        // 4. Retorna dados de bloqueio
        return std::unexpected(addContext(checkBlock(user).error(), "Devolução realizada com sucesso."));
    }

    // 4. Verifica limite de renovações
    if (state.n_Renov >= LIMITE_RENOVACOES) {
        return std::unexpected(forbidden("Limite de renovações atingido."));
    }

    // 5. Renova empréstimo
    auto res = loans.renovar(state.loan_id, PRAZO_DIAS);
    if (!res) {
        return std::unexpected(addContext(res.error(),
            "Não foi possível renovar o empréstimo: "));
    }

    return {};
}

ECM::Result LibService::reservar(const UserId& user_id, const BookId& book_id){
    // 1. Buscando o status do usuário
    auto res = users.getUserState(user_id);
    if (!res) {
        return std::unexpected(addContext(res.error(),
            "Não foi possível realizar a reserva pois não foi possível verificar o status do usuário: "));
    }
    UserState state = res.value();
    // 2. Verificando se ele se encontra bloqueado ou inativo
    auto check = checkBlock(state);
    if (!check) {
        return std::unexpected(addContext(check.error(),
            "Não foi possível efetivar a reserva: "));
    }
    // 3. verificando se o usuário já possui reserva ativa no mesmo título
    auto check2 = reserva.usuarioJaReservou(user_id, book_id);
    if (!check2) {
        return std::unexpected(check2.error());
    }
    // 4. verificando se o usuário possui empréstimo ativo no mesmo título
    auto res_loans = loans.temEmprestimo(user_id, book_id);
    if (!res_loans) {
        return std::unexpected(addContext(res_loans.error(), "Não foi possível fazer a reserva: "));
    }
    // 5. verificando se não há itens disponíveis no mesmo título
    auto check_disp = items.quantosDisponiveis(book_id);
    if (!items.quantosDisponiveis(book_id)) {
        return std::unexpected(conflict("Não foi possível efetivar a reserva pois não foi possível verificar se há itens disponíveis."));
    }
    if (check_disp.value()) {
        return std::unexpected(conflict("Não foi possível efetivar a reserva: há itens disponíveis deste título!"));
    }
    //6. Verificando se o usuário excedeu o limite de empréstimos + reservas ativas
    auto check_limit = LibService::checkLimit(user_id);
    if (!check_limit) {
        return std::unexpected(check_limit.error());
    }
    
    // 7. efetivando reserva
    auto result = reserva.inserir(Reserva(user_id, book_id, today()));

    if (!result) {
        return std::unexpected(addContext(result.error(), "Não foi possível fazer a reserva: "));
    }

    return{};
}



====================
// ARQUIVO: .\application\LibService.h
====================
#pragma once

/* Essa é a classe que coordena, orquestra, o que cada repositório deve fazer em cada serviço básico da
biblioteca: emprestar, receber devolução, renovar empréstimo e reservar um título. É aqui que devem ser
implementadas as regras de negócio, isto é, por quanto tempo um usuário ter um item emprestado, quantas
renovações são possíveis no máximo, em quais casos alguém pode reservar um título, etc. Além destes 
serviços básicos, esta classe também está dotada de métodos auxiliares. */

#include "../infra/repositories/UserRepository.h"
#include "../infra/repositories/BookRepository.h"
#include "../infra/repositories/ItemRepository.h"
#include "../infra/repositories/LoanRepository.h"
#include "../infra/repositories/SearchRepository.h"
#include "../infra/repositories/ReservaRepository.h"


class LibService {
public:
    LibService(
        Database& db,
        UserRepository& users,
        BookRepository& books,
        ItemRepository& items,
        LoanRepository& loans,
        SearchRepository& searches,
        ReservaRepository& reserva
    );
    //------------- util/Transactions ---------------
    Error handleRollback(Error erroOriginal);
    //------------- checks --------------------------
    ECM::Result checkBlock(const UserId id_user);
    ECM::Result checkBlock(const UserState state);
    ECM::Result checkLimit(const UserId& id_user);
    ECM::Result meetCriteria(const UserId& id_user);
    //------------- register ------------------------
    ECM::Result cadastrarLivro(const Book& b);
    ECM::Result salvarUsuario(const User& u);
    ECM::Result adicionarItem(const BookId& id, int n);
    //-------------- read ---------------------------
    ECM::Expected<std::vector<BookSearchResult>> buscarLivros(std::string_view term, BookSearchField field);
    ECM::Expected<std::vector<UserSearchResult>> buscarUsuario(std::string_view term);
    ECM::Expected<std::vector<UserSearchResult>> buscarUsuarioId(const UserId& id);
    ECM::Expected<User> idToUser(const UserId& id);
    ECM::Expected<std::vector<ReservaInfo>> buscarReservas(const UserId&);
    //-------------- modify -------------------------
    ECM::Result alterarUsuario(const User& u);
    ECM::Result cancelarReserva(int id);
    //-------------- forecast -----------------------
    ECM::Expected<std::chrono::year_month_day> preverDisponibilidade(const BookId& book);
    //-------------- services------------------------
    ECM::Expected<Loan> emprestar(const UserId& id_user, const ItemId& id_item);
    ECM::Result devolver(const UserId& user, const ItemId& item);
    ECM::Result renovar(const UserId& user, const ItemId& item);
    ECM::Result reservar(const UserId&, const BookId&);
private:
    Database& db;
    UserRepository& users;
    BookRepository& books;
    ItemRepository& items;
    LoanRepository& loans;
    SearchRepository& searches;
    ReservaRepository& reserva;
};

inline std::chrono::days prazoPerRole(UserRole role) {
    if (role == UserRole::Normal) {
        return  std::chrono::days(14);
    }
    return std::chrono::days(14);
}




====================
// ARQUIVO: .\core\BookSearchField.h
====================
﻿#pragma once

enum class BookSearchField {
    Title,
    Author,
    TitleOrAuthor
};


====================
// ARQUIVO: .\core\UserSearchField.h
====================
﻿#pragma once

enum class UserSearchField {
    Id,
    Nome
};



====================
// ARQUIVO: .\core\dto\BookSearchResult.h
====================
﻿#pragma once

#include "../ids/BookId.h"
#include <string>

struct BookSearchResult {
    BookId book_id;
    std::string title;
    std::string subtitle;
    std::string author;

    int total_items;
    int available;
    int loaned;
};



====================
// ARQUIVO: .\core\dto\ReservaInfo.h
====================
﻿#pragma once
#include <string>


struct ReservaInfo {
	int id_reserva;
	int id_user;
	std::string nome_user;
	std::string nome_livro;
};


====================
// ARQUIVO: .\core\dto\UserSearchResult.h
====================
﻿#pragma once

#include "../ids/UserId.h"
#include <string>

struct UserSearchResult {
    UserId user_id;
    std::string nome;
};


====================
// ARQUIVO: .\core\entities\Book.h
====================
﻿#pragma once
#include <string>
#include "../ids/BookId.h"

class Book {
public:
    BookId id;
    std::string titulo;
    std::string subtitulo;
    std::string autor;
    std::string assunto;
    std::string colecao;
    std::string isbn;
    int copias;

    Book(BookId id,
        std::string titulo,
        std::string subtitulo,
        std::string autor,
        std::string assunto,
        std::string colecao,
        int copias)
        : id(id),
        titulo(std::move(titulo)),
        subtitulo(std::move(subtitulo)),
        autor(std::move(autor)),
        assunto(std::move(assunto)),
        colecao(std::move(colecao)),
        copias(copias){
    }

   static std::string get_Item(int i) {
        if (i > 0 && i < 10) {
            return "0" + std::to_string(i);
        }
        else {
            return std::to_string(i);
        }
    }
};



====================
// ARQUIVO: .\core\entities\Item.h
====================
﻿#pragma once
#include "../ids/ItemId.h"

/* Uma possibilidade de adapatação é acrescentar um enum class com o estado (disponível, emprestado) e alterar
a tabela/repositório de itens de acordo. Isso é uma ótima escolha pensando em performance, mas sacrifica 
a consistência: é importante tomar cuidado para atualizar o status sempre que chamar um método da LibService
como emprestar, devolver, etc, sob o risco de criar dados inconsistentes. É necessário fazer isso se o 
sistema crescer muito */

class Item {
public:
    ItemId id;
    BookId book_id;
};



====================
// ARQUIVO: .\core\entities\Loan.h
====================
﻿#pragma once

#include "Item.h"
#include "User.h"
#include "../states/LoanState.h"
#include <string>
#include <chrono>

class Loan {
public:
    int id;
    ItemId item_id;
    UserId user_id;
    LoanStatus status;

    std::chrono::year_month_day loaned_at;
    std::chrono::year_month_day due_at;
    std::optional<std::chrono::year_month_day> returned_at; 
    int n_Renov = 0;

    Loan() = default;

    
    Loan(int id, const ItemId& item_id, const UserId& user_id,
        const std::chrono::year_month_day& loaned,
        const std::chrono::year_month_day& due)
        : id(id), item_id(item_id), user_id(user_id), status(LoanStatus::Ativo),
        loaned_at(loaned), due_at(due) {
    }

    std::string get_Id() const {
        return std::to_string(id);
    }

    static std::string loanToStatus(LoanStatus s) {
        switch (s) {
        case LoanStatus::Ativo: return "Ativo";
        case LoanStatus::Atrasado: return "Atrasado";
        case LoanStatus::Devolvido: return "Devolvido";
        }
    }

    static LoanStatus parseLoanStatus(int s) {
        switch (s) {
        case 1: return LoanStatus::Ativo;
        case 2: return LoanStatus::Atrasado;
        default: return LoanStatus::Devolvido;
        }
    }
};



====================
// ARQUIVO: .\core\entities\Reserva.h
====================
﻿#pragma once
#include <chrono>
#include "../ids/UserId.h"
#include "../ids/BookId.h"

enum class ReservaStatus {
    Ativa = 1,
    Atendida = 0,
    Cancelada = -1,
    AguardandoRetirada = 2
};

class Reserva {
public:
    Reserva(UserId user,
        BookId book,
        std::chrono::year_month_day data) : user(user), book(book), data(data) {
        id = 0;
        status = ReservaStatus::Ativa;
    };

    const int getId() const { return id; };
    const UserId& getUser() const { return user; };
    const BookId& getBook() const { return book; };
    ReservaStatus getStatus() const { return status; };
    std::chrono::year_month_day getData() const { return data; };

    //void cancelar();
    //void atender();

    static ReservaStatus parseReservaStatus(int s) {
        switch (s) {
        case 0: return ReservaStatus::Atendida;
        case 2: return ReservaStatus::Cancelada;
        case 1: return ReservaStatus::Ativa;
        }
    }

private:
    int id;
    UserId user;
    BookId book;
    std::chrono::year_month_day data;
    ReservaStatus status;
};




====================
// ARQUIVO: .\core\entities\User.h
====================
﻿#pragma once
#include <string>
#include "../ids/UserId.h"
#include "../states/UserRole.h"
#include "../states/UserState.h"
#include "../value_objects/email.h"

class User {
public:
    UserId id;
    std::string nome;
    Email email;
    std::string tel;
    UserRole role;
    UserStatus status;
    std::optional<std::chrono::year_month_day> blocked_until;

    User() = default;
    User(UserId id, std::string nome, Email email, std::string tel)
        :id(id), nome(nome), email(email), tel(tel) {
        role = UserRole::Normal;
        status = UserStatus::Ativo;
    }
    User(UserId id, 
        std::string nome,
        Email email,
        std::string tel, 
        UserStatus status, 
        std::optional<std::chrono::year_month_day> blocked_until)
        :id(id), nome(nome), email(email), tel(tel), status(status), blocked_until(blocked_until) {}

    static std::string roletostr(UserRole r) {
        switch (r) {
        case UserRole::Normal: return "Normal";
        case UserRole::Professor: return "Professor";
        }
    }

    static std::string statustostr(UserStatus s) {
        switch (s) {
        case UserStatus::Ativo: return "Ativo";
        case UserStatus::Bloqueado: return "Bloqueado";
        case UserStatus::Inativo: return "Inativo";
        }
    }

    static UserRole parseUserRole(int s) {
        switch (s) {
        case 1: return UserRole::Normal;
        default: return UserRole::Normal;
        }
    }

    static UserStatus parseUserStatus(int s) {
        switch (s) {
        case 0: return UserStatus::Inativo;
        case 2: return UserStatus::Bloqueado;
        default: return UserStatus::Ativo;
        }
    }
};


====================
// ARQUIVO: .\core\errors\errors.h
====================
﻿#pragma once

#include "../utils/TimeUtils.h"

#include <expected>
#include <string>
#include <variant>
#include <chrono>

    struct Extra {
        std::optional<std::chrono::year_month_day> blocked_until;
    };

    // -------------------------

    // Erro de aplicação

    // -------------------------

    struct Error {

        enum class Type {
            Unknown,
            NotFound,       // entidade não existe
            DatabaseError,  // falha técnica (sqlite, IO, etc)
            Validation,     // dado inválido
            Blocked,        // usuário bloqueado
            Inactive,       // usuário inativo
            Overdue,        // empréstimo atrasado
            Conflict,        // estado inválido (ex: item já emprestado)
            Forbidden,        // por ex., já renovou muitas vezes
            Reserved         // obra reservada
        };


        Type type{ Type::Unknown };

        std::string message{};

        Extra extra{};

    };

    // -------------------------
    // Alias padrão de retorno
    // -------------------------

    namespace ECM {

        template <typename T>
        using Expected = std::expected<T, Error>;

        using Result = Expected<void>;

    }

    // -------------------------
    // Helpers 
    // -------------------------

    inline Error unknown(std::string msg) {
        return { Error::Type::Unknown, std::move(msg)};
    }

    inline Error notFound(std::string msg) {
        return { Error::Type::NotFound, std::move(msg) };
    }

    inline Error database(std::string msg) {
        return { Error::Type::DatabaseError, std::move(msg) };
    }

    inline Error validation(std::string msg) {
        return { Error::Type::Validation, std::move(msg)};
    }

    inline Error blocked(std::string msg = "Usuário bloqueado sem data de desbloqueio.") {
        return Error{
            .type = Error::Type::Blocked,
            .message = std::move(msg)
        };
    }

    inline Error blocked(std::chrono::year_month_day data, std::string msg = "Usuário bloqueado até: ") {
        return Error{
            .type = Error::Type::Blocked,
            .message = std::move(msg) + timeToStringUser(data),
            .extra = Extra{data}
        };
    }

    inline Error inactive(std::string msg = "Usuário inativo.") {
        return { Error::Type::Inactive, std::move(msg)};
    }

    inline Error conflict(std::string msg) {
        return { Error::Type::Conflict, std::move(msg)};
    }

    inline Error overdue(std::chrono::year_month_day data,
        std::string msg = "Empréstimo em atraso!") { 
        return { Error::Type::Overdue, std::move(msg), Extra{data} };
    }

    inline Error forbidden(std::string msg) {
        return { Error::Type::Conflict, std::move(msg), {} };
    }

    inline Error reserved(std::string msg) {
        return { Error::Type::Reserved, "Este livro possui reserva!\nSeparar este exemplar!\nReservado por: " + std::move(msg), {} };
    }

    inline Error addContext(Error e, const std::string& ctx) {
        e.message = ctx + "\n" + e.message;
        return e;
    }


====================
// ARQUIVO: .\core\ids\BookId.h
====================
﻿#pragma once
#include "../errors/errors.h"
#include <string>
#include <string_view>

#define BOOK_ID_SIZE 5
#define BOOK_PREFIX 'L'

class BookId {
private:
    int id;
    BookId(int id) : id(id) {};
    BookId(const std::string& id_) {
        id = std::stoi(id_); //está protegido por validação, TODO: talvez melhorar isso depois
    }
public:
    static BookId fromDatabase(int raw) {
        return BookId(raw);
    }
    static ECM::Expected<BookId> create(std::string s) {
        if (s.empty()) {
            return std::unexpected(validation("Id vazio!"));
        }
        int startpoint = 0;
        int size_max = BOOK_ID_SIZE + 3;
        if (s[0] == BOOK_PREFIX) {
            if (s.size() == 1) {
                return std::unexpected(validation("Id vazio!"));
            }
            startpoint = 1;
            size_max++;
        }
        if (s.size() > size_max) {
            return std::unexpected(validation("Id muito grande!"));
        }
        auto pos = s.find('-');
        if (pos != std::string::npos) {
            s.erase(pos); // apaga de pos até o fim
        }
        for (int i = startpoint; i < s.size(); i++) {
            if (!std::isdigit(static_cast<unsigned char>(s[i]))) {
                return std::unexpected(validation("Foram inseridos caracteres inválidos!")); 
            }
        }
        std::string id_(s.substr(startpoint));
        return BookId(id_);
    }
    int get_Id_int() const { return id; };
    std::string get_Id_raw() const {
        std::string s = std::to_string(id);
        return s;
    }
    std::string get_Id_format() const {
        std::string s = std::to_string(id);
        int lack = BOOK_ID_SIZE - 1 - s.size();
        if (lack > 0) {
            for (int i = 0; i < lack; i++) {
                s = "0" + s;
            }
        }
        return "L" + s;
    };
};


====================
// ARQUIVO: .\core\ids\ItemId.h
====================
﻿#pragma once

#include <string>
#include <string_view>
#include "BookId.h"

#define Item_ID_SIZE 8


class ItemId {
private:
    BookId book;
    int copyNumber;
    ItemId(BookId book, int copyNumber) : book(book), copyNumber(copyNumber) {};
public:
    static ECM::Expected<ItemId> create(std::string s) {
        int copyNumber;
        int size_max = Item_ID_SIZE + 3;
        if (s.empty()) {
            return std::unexpected(validation("Id vazio!"));
        }
        if (s.size() > size_max) {
            return std::unexpected(validation("Id muito grande!"));
        }
        std::size_t pos_hifen;
        bool hasHifen = false;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '-') {
                hasHifen = true;
                pos_hifen = i;
                break;
            }
        }
        if (!hasHifen) {
            return std::unexpected(validation("Falta um hífen!"));
        }

        auto test = BookId::create(s.substr(0, pos_hifen));
        if (!test.has_value()) {
            return std::unexpected(test.error());
        }
        BookId book = test.value();
        for (int i = pos_hifen + 1; i < s.size(); i++) {
            if (!std::isdigit(static_cast<unsigned char>(s[i]))) {
                return std::unexpected(validation("Foram inserido caracteres inválidos!"));
            }
        }
        copyNumber = std::stoi(std::string(s.substr(pos_hifen + 1)));


        return ItemId(book, copyNumber);
    }

    std::string get_Id() const {
        if (copyNumber < 10) {
            return book.get_Id_format() + "-0" + std::to_string(copyNumber);
        }
        return book.get_Id_format() + "-" + std::to_string(copyNumber);
    };

    BookId getBook() const {
        return book;
    }

    int getExemp() const {
        return copyNumber;
    }

};



====================
// ARQUIVO: .\core\ids\UserId.h
====================
﻿#pragma once
#include "../errors/errors.h"
#include <string>
#include <string_view>

#define USER_ID_SIZE 5
#define USER_PREFIX 'M'

class UserId {
private:
    int id;
    UserId(int id) : id(id) {}
    UserId(const std::string& id_) {
        id = std::stoi(id_); //está protegido por validação. TODO: talvez melhorar isso depois
    }
public:
    static UserId fromDatabase(int raw) {
        return UserId(raw);
    }
    static ECM::Expected<UserId> create(std::string_view s) {
        if (s.empty()) {
            return std::unexpected(validation("Id vazio!"));
        }
        int startpoint = 0;
        size_t size = USER_ID_SIZE;
        if (s[0] == USER_PREFIX) {
            if (s.size() == 1) {
                return std::unexpected(validation("Id vazio!"));
            }
            startpoint = 1;
            size++;
        }
        if (s.size() > size) {
            return std::unexpected(validation("Id muito grande!"));
        }
        for (int i = startpoint; i < s.size(); i++) {
            if (!std::isdigit(static_cast<unsigned char>(s[i]))) {
                return std::unexpected(validation("Foram inseridos caracteres inválidos!"));
            }
        }
        std::string id_(s.substr(startpoint));
        return UserId(id_);
    }
    int get_Id_int() const { return id; };
    std::string get_Id_raw() const {
        std::string s = std::to_string(id);
        return s;
    }
    std::string get_Id_format() const {
        std::string s = std::to_string(id);
        size_t lack = USER_ID_SIZE - 1 - s.size();
        if (lack > 0) {
            for (size_t i = 0; i < lack; i++) {
                s = "0" + s;
            }
        }
        return "M" + s;
    };
};




====================
// ARQUIVO: .\core\states\LoanState.h
====================
﻿#pragma once

#include<optional>

enum class LoanStatus {
    Ativo = 1,
    Devolvido = 0,
    Atrasado = 2
};

struct LoanState {
    int loan_id;
    LoanStatus status;
    std::chrono::year_month_day due_at;
    int n_Renov;
    std::optional<std::chrono::year_month_day> returned_at;
};



====================
// ARQUIVO: .\core\states\UserRole.h
====================
﻿#pragma once

enum class UserRole {
    Normal,
    Professor
};


====================
// ARQUIVO: .\core\states\UserState.h
====================
﻿#pragma once

#include <optional>
#include <chrono>

enum class UserStatus {
    Ativo = 1,
    Bloqueado = 2,
    Inativo = 0
};

struct UserState {
    UserStatus status;
    UserRole role;
    std::optional<std::chrono::year_month_day> blocked_until ;
};



====================
// ARQUIVO: .\core\utils\TimeUtils.h
====================
﻿#pragma once

#include <string>
#include <chrono>
#include <format>

inline std::string timeToString(const std::chrono::system_clock::time_point& tp) {
	std::chrono::sys_time<std::chrono::days> tp_day = std::chrono::floor<std::chrono::days>(tp);
	const std::chrono::time_zone* fuso = std::chrono::current_zone();
	std::chrono::zoned_time tempo_local(fuso, tp_day);
	return std::format("{:%Y%m%d}", tempo_local);
}

inline std::string timeToString(const std::chrono::year_month_day& tp) {
	return std::format("{:%Y%m%d}", tp);
}

inline std::chrono::year_month_day today() {
	return std::chrono::year_month_day{ std::chrono::floor<std::chrono::days>(
		std::chrono::system_clock::now()) };
}

inline std::string timeToStringUser(const std::chrono::year_month_day& tp) {
	return std::format("{:%d/%m/%Y}", tp);
}

inline std::chrono::year_month_day parseDate(const std::string& s) {
	int y = std::stoi(s.substr(0, 4));
	unsigned m = static_cast<unsigned>(std::stoi(s.substr(4, 2)));
	unsigned d = static_cast<unsigned>(std::stoi(s.substr(6, 2)));
	return std::chrono::year{ y } /
		std::chrono::month{ m } /
		std::chrono::day{ d };
}



====================
// ARQUIVO: .\core\value_objects\email.h
====================
﻿#pragma once

#include "../errors/errors.h"

#include <string>
#include <expected>
#include <regex>

class Email {
public:
	static ECM::Expected<Email> create(std::string s) {
		if (s.empty()) {
			return std::unexpected(validation("E-mail vazio!"));
		}
		const std::regex pattern(R"(^\S+@\S+\.\S+$)");
		if (!std::regex_match(s, pattern)) return std::unexpected(validation("E-mail inválido!"));

		return Email(s);
	}

	const std::string& get() const {
		return address;
	}

	static Email fromDatabase(std::string s) {
		return Email(s);
	}
private:
	std::string address;
	Email(const std::string& s) : address(s) {}
};



====================
// ARQUIVO: .\core\value_objects\flags.h
====================
﻿#pragma once

enum class flags {
	vazio,
	invalido
};



====================
// ARQUIVO: .\devtools\database_feed.cpp
====================
﻿#include "database_feed.h"
#include "../infra/feed/feed.h"
#include <iostream>


void database_feed(LibService& serv) {
    auto result = db_feed(serv);
    if (!result) {
        std::cout << "Erro ao alimentar o banco de dados: " << result.error().message << std::endl;
    }
    else {
        std::cout << "Banco de dados alimentado com sucesso!" << std::endl;
    }
    system("pause");
}


====================
// ARQUIVO: .\devtools\database_feed.h
====================
﻿#pragma once
#include "../application/LibService.h"

void database_feed(LibService& serv);



====================
// ARQUIVO: .\devtools\main_dev.cpp
====================
﻿#include "../ui/utils/exibirSelecao.h"
#include "homolog/homolog.h"
#include "database_feed.h"
#include <string>
#include <iostream>

void main_dev(LibService& serv) {
    std::array<std::string, 3> menuDev = {
        "Ambiente de Homologação",
        "Resetar banco de dados",
        "Voltar"
    };
    

    while (true) {
        clearScreen();
        std::cout << "=================== Ambiente de Dev ====================\n\n";
        int escolha = exibirSelecao(menuDev);

        switch (escolha) {
        case 0:
            homolog();
            break;
        case 1:
            database_feed(serv);
            break;
        case 2:
            clearScreen();
            std::cout << "Biblioteca Edvaldo Cardoso Mattos\nPrimeira Igreja Batista em Taboão da Serra\n\n";
            return;
        }
    }
}


====================
// ARQUIVO: .\devtools\main_dev.h
====================
﻿#pragma once

#include "../application/LibService.h"

void main_dev(LibService& serv);



====================
// ARQUIVO: .\devtools\homolog\homolog.cpp
====================
﻿#include "../../application/LibService.h"

#include "../../infra/db/sqlite_database.h"
#include "../../infra/db/init.h"
#include "../../infra/repositories/UserRepository.h"
#include "../../infra/repositories/BookRepository.h"
#include "../../infra/repositories/ItemRepository.h"
#include "../../infra/repositories/LoanRepository.h"
#include "../../infra/repositories/SearchRepository.h"


#include "../../ui/utils/exibirSelecao.h"

#include "MenuHomolog.h"


#include <iostream>

void homolog() {
    SqliteDatabase db_homolog("biblioteca_homolog.db");

    auto init = dbInitializer::criarTabelas(db_homolog);

    if (!init) {
        std::cout << "Erro na criação de tabelas: " << init.error().message << std::endl;
        system("pause");
        return;
    }

    UserRepository users_homolog(db_homolog);
    BookRepository books_homolog(db_homolog);
    ItemRepository items_homolog(db_homolog);
    LoanRepository loans_homolog(db_homolog);
    SearchRepository searches_homolog(db_homolog);
    ReservaRepository reserva_homolog(db_homolog);

    LibService serv_homolog(db_homolog, users_homolog, books_homolog, items_homolog, loans_homolog, searches_homolog, reserva_homolog);

    MenuHomolog(serv_homolog);
}


====================
// ARQUIVO: .\devtools\homolog\homolog.h
====================
﻿#pragma once

void homolog();



====================
// ARQUIVO: .\devtools\homolog\MenuHomolog.cpp
====================
﻿#include "MenuHomolog.h"

#include "../../ui/controller/MenuOutros.h"

#include "../../ui/screens/CadastrarUsuario.h"
#include "../../ui/screens/RegistrarEmprestimo.h"
#include "../../ui/screens/RegistrarDevolucao.h"
#include "../../ui/screens/renovacao.h"
#include "../../ui/utils/exibirSelecao.h"

#include "../database_feed.h"

#include <string>

#include <iostream>

void MenuHomolog(LibService& serv) {
    std::array<std::string, 7> menuPrincipal = {
        "Registrar empréstimo",
        "Registrar devolução",
        "Renovar empréstimo",
        "Cadastrar novo usuário",
        "Alimentar banco de dados",
        "Outros",
        "Sair"
    };

    
    while (true) {
        clearScreen();
        std::cout << "=================== Ambiente de Homologação ====================\n\n";

        int escolha = exibirSelecao(menuPrincipal); 

        switch (escolha) {
        case 0:
            registrarEmprestimo(serv);
            break;
        case 1:
            registrarDevolucao(serv);
            break;
        case 2:
            renovacao(serv);
            break;
        case 3:
            cadastrarUsuario(serv);
            break;
        case 4:
            database_feed(serv);
            break;
        case 5:
            clearScreen();
            std::cout << "=================== Ambiente de Homologação ====================\n\n";
            menuOutros(serv);
            break;
        case 6:
            clearScreen();
            std::cout << "=================== Ambiente de Dev ====================\n\n";
            return;
        }
    }
}




====================
// ARQUIVO: .\devtools\homolog\MenuHomolog.h
====================
﻿#pragma once

#include "../../application/LibService.h"

void MenuHomolog(LibService& serv);



====================
// ARQUIVO: .\infra\db\database.h
====================
﻿#pragma once

#include "statement.h"

#include <memory>


class Database {
public:
    virtual ~Database() = default;

    virtual ECM::Result exec(std::string_view sql) = 0;
    virtual ECM::Expected<std::unique_ptr<Statement>> prepare(const std::string& sql) = 0;

    virtual ECM::Result begin() = 0;
    virtual ECM::Result commit() = 0;
    virtual ECM::Result rollback() = 0;
};




====================
// ARQUIVO: .\infra\db\Init.cpp
====================
﻿#include "init.h"


 ECM::Result dbInitializer::criarTabelas(Database& db) {


    ECM::Result status_membros = db.exec(R"(
        CREATE TABLE IF NOT EXISTS membros(
            id TEXT PRIMARY KEY,
            nome TEXT NOT NULL,
            email TEXT,
            tel TEXT,
            role INTEGER DEFAULT 1,
            status INTEGER DEFAULT 1,
            blocked_until TEXT DEFAULT NULL,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        );
      )");

    ECM::Result status_livros = db.exec(R"(
        CREATE TABLE IF NOT EXISTS livros(
            id INTEGER PRIMARY KEY, 
            titulo TEXT NOT NULL,
            subtitulo TEXT,
            autor TEXT,
            assunto TEXT,
            colecao TEXT,
            isbn TEXT,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
         ); 
       )");

    ECM::Result status_itens = db.exec(R"(
        CREATE TABLE IF NOT EXISTS itens(
            id TEXT PRIMARY KEY,
            book_id INTEGER NOT NULL,
            FOREIGN KEY (book_id) REFERENCES livros(id)
        );
    )");

    ECM::Result status_loans = db.exec(R"(
        CREATE TABLE IF NOT EXISTS loans(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            item_id TEXT NOT NULL,
            user_id TEXT NOT NULL,
            loaned_at TEXT DEFAULT CURRENT_TIMESTAMP,
            due_at TEXT NOT NULL,
            n_Renov INTEGER DEFAULT 0,
            returned_at TEXT,
            status INTEGER NOT NULL DEFAULT 1,
            FOREIGN KEY(item_id) REFERENCES itens(id), 
            FOREIGN KEY(user_id) REFERENCES membros(id)
        ); 
    )");

    ECM::Result status_reservas = db.exec(R"(
        CREATE TABLE IF NOT EXISTS reservas (
            id INTEGER PRIMARY KEY,
            user_id INTEGER NOT NULL,
            book_id INTEGER NOT NULL,
            data_reserva TEXT NOT NULL,
            status INTEGER NOT NULL,
            FOREIGN KEY(user_id) REFERENCES membros(id),
            FOREIGN KEY(book_id) REFERENCES livros(id)
       );
    )");

    bool has_error = false;
    Error erro = database("Erro ao criar as tabelas: ");

    if (!status_membros.has_value()) {
        has_error = true;
        erro = addContext(erro, "membros (" + (status_membros.error().message) + ");");
    }
    if (!status_livros.has_value()) {
        has_error = true;
        erro = addContext(erro, "livros (" + (status_membros.error().message) + ");");
    }
    if (!status_itens.has_value()) {
        has_error = true;
        erro = addContext(erro, "itens (" + (status_membros.error().message) + ");");
    }
    if (!status_loans.has_value()) {
        has_error = true;
        erro = addContext(erro, "loans (" + (status_membros.error().message) + ");");
    }
    if (!status_reservas.has_value()) {
        has_error = true;
        erro = addContext(erro, "reservas (" + (status_membros.error().message) + ");");
    }
    if (has_error) {
        return std::unexpected(erro);
    }
    return {};
}



====================
// ARQUIVO: .\infra\db\Init.h
====================
﻿#pragma once
#include "database.h"

class dbInitializer {
public:
    static ECM::Result criarTabelas(Database& db);
private:
    dbInitializer() = delete;
};


//int criarTabela(sqlite3* db, const char* sql, const char* nome);
//void inicializarBanco(Database& db);




====================
// ARQUIVO: .\infra\db\sqlite_database.cpp
====================
﻿#include "sqlite_database.h"

#include "sqlite_statement.h"

#include <stdexcept>

SqliteDatabase::SqliteDatabase(const std::string& filename)
    : db_(nullptr)
{
    if (sqlite3_open(filename.c_str(), &db_) != SQLITE_OK) {
        throw std::runtime_error(sqlite3_errmsg(db_));
    }
}

SqliteDatabase::~SqliteDatabase() {
    if (db_) sqlite3_close(db_);
}

ECM::Result SqliteDatabase::exec(std::string_view sql) { 
    if (sqlite3_exec(db_, sql.data(), nullptr, nullptr, nullptr)!= SQLITE_OK) {
        return std::unexpected(database(sqlite3_errmsg(db_)));
    }
    return {};
}

ECM::Expected<std::unique_ptr<Statement>> SqliteDatabase::prepare(const std::string& sql) {
    sqlite3_stmt* stmt_ptr = nullptr;

    // O SQLite tenta compilar a query SQL
    int rc = sqlite3_prepare_v2(db_, sql.c_str(), -1, &stmt_ptr, nullptr);

    if (rc != SQLITE_OK) {
        // Se deu erro (tabela não existe, erro de sintaxe, etc.)
        // Pegamos a mensagem de erro direto do handle do banco
        std::string erroMsg = sqlite3_errmsg(db_);
        return std::unexpected(database(erroMsg));
    }

    // Se deu certo, encapsulamos o ponteiro bruto em um unique_ptr e retornamos sucesso
    return std::make_unique<SqliteStatement>(stmt_ptr);
}

ECM::Result SqliteDatabase::begin() {
    if (sqlite3_exec(db_, "BEGIN;", nullptr, nullptr, nullptr) != SQLITE_OK) {
        return std::unexpected(database(sqlite3_errmsg(db_)));
    }
    return {};
}

ECM::Result SqliteDatabase::commit() {
    //last_error_.clear();
    if (sqlite3_exec(db_, "COMMIT;", nullptr, nullptr, nullptr) != SQLITE_OK) {
        return std::unexpected(database(sqlite3_errmsg(db_)));
    }
    return {};
}

ECM::Result SqliteDatabase::rollback() {
    //last_error_.clear();
    if (sqlite3_exec(db_, "ROLLBACK;", nullptr, nullptr, nullptr) != SQLITE_OK) {
        return std::unexpected(database(sqlite3_errmsg(db_)));
    }
    return {};
}


sqlite3* SqliteDatabase::raw() { return db_; }



====================
// ARQUIVO: .\infra\db\sqlite_database.h
====================
﻿#pragma once

#include "database.h"
#include "statement.h"

#include "../../external/sqlite/sqlite3.h"



class SqliteDatabase : public Database {
public:
    explicit SqliteDatabase(const std::string& path);
    ~SqliteDatabase();

    ECM::Result exec(std::string_view sql) override;
    ECM::Expected<std::unique_ptr<Statement>> prepare(const std::string& sql) override;

    ECM::Result begin() override;
    ECM::Result commit() override;
    ECM::Result rollback() override;

    sqlite3* raw();

     
private:
    sqlite3* db_;
};




====================
// ARQUIVO: .\infra\db\sqlite_statement.cpp
====================
﻿#include "sqlite_statement.h"



SqliteStatement::SqliteStatement(sqlite3_stmt* stmt)
    : stmt_(stmt), has_row_(false)
{
  
}

SqliteStatement::~SqliteStatement() {
    if (stmt_) sqlite3_finalize(stmt_);
}

void SqliteStatement::bind(int i, const std::string& v) {
    sqlite3_bind_text(stmt_, i, v.c_str(), -1, SQLITE_TRANSIENT);
}

void SqliteStatement::bind(int i, int v) {
    sqlite3_bind_int(stmt_, i, v);
}

ECM::Result SqliteStatement::step() {
    int status = sqlite3_step(stmt_);

    if (status == SQLITE_ROW) { has_row_ = true; return {}; }
    if (status == SQLITE_DONE) { has_row_ = false; return {}; }

    int extended_status = sqlite3_errcode(sqlite3_db_handle(stmt_));
    std::string msg = sqlite3_errmsg(sqlite3_db_handle(stmt_));

    if (extended_status == SQLITE_CONSTRAINT) {
        return std::unexpected(Error{ Error::Type::Conflict, "Conflict: " + msg });
    }

    return std::unexpected(database(msg));
}

int SqliteStatement::columnInt(int col) {
    return sqlite3_column_int(stmt_, col);
}


std::string SqliteStatement::columnText(int col) {
    const auto* text = reinterpret_cast<const char*>(sqlite3_column_text(stmt_, col)); 
    return text ? std::string(text) : std::string("");
}

void SqliteStatement::reset() {
    sqlite3_reset(stmt_);
    sqlite3_clear_bindings(stmt_);
    has_row_ = false;
}

bool SqliteStatement::hasRow() {
    return has_row_;
}


====================
// ARQUIVO: .\infra\db\sqlite_statement.h
====================
﻿#pragma once
#include "statement.h"
#include <sqlite3.h>

class SqliteStatement : public Statement {
public:
    SqliteStatement(sqlite3_stmt* stmt);
    ~SqliteStatement() override;

    void bind(int index, const std::string& value) override;
    void bind(int index, int value) override;
    ECM::Result step() override;
    bool hasRow() override;
    int columnInt(int col) override;
    std::string columnText(int col) override;
    void reset() override;

private:
    sqlite3_stmt* stmt_;
    bool has_row_;
};




====================
// ARQUIVO: .\infra\db\statement.h
====================
﻿#pragma once

#include <string>
#include "../../core/errors/errors.h"

class Statement {
public:
    virtual ~Statement() = default;

    virtual void bind(int index, const std::string& value) = 0;
    virtual void bind(int index, int value) = 0;
    virtual ECM::Result step() = 0;
    virtual bool hasRow() = 0;
    virtual int columnInt(int col) = 0;
    virtual std::string columnText(int col) = 0;

    virtual void reset() = 0;
};



====================
// ARQUIVO: .\infra\db\update.cpp
====================
﻿#include "update.h"

ECM::Result updateDb(Database& db) {
	auto update_loans = db.exec(R"(
        UPDATE loans SET status = 2 WHERE status = 1 AND due_at < strftime('%Y%m%d', 'now');
    )");

	if (!update_loans) {
		return update_loans;
	}

	auto update_membros = db.exec(R"(
        UPDATE membros SET status = 2 WHERE id IN (SELECT user_id FROM loans WHERE status = 2)
    )");

	if (!update_membros) {
		return update_membros;
	}

	/* Lembrar de atualizar a tabela de itens caso decidir que ela deve guardar o status */
	
	   
	return {};
}


====================
// ARQUIVO: .\infra\db\update.h
====================
﻿#pragma once

#include "database.h"

ECM::Result updateDb(Database& db);



====================
// ARQUIVO: .\infra\feed\feed.cpp
====================
﻿#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <iostream>

#include "feed.h"

std::vector<std::string> splitTSV(const std::string& line) {
    std::vector<std::string> fields;
    std::stringstream ss(line);
    std::string field;

    while (std::getline(ss, field, '\t')) {
        fields.push_back(field);
    }

    return fields;
}

ECM::Result db_feed(LibService& serv) {
    std::ifstream file("livros.tsv"); // trate o arquivo como um fluxo de dados de entrada
    file.imbue(std::locale("")); // std::locale funciona como um conjunto de regras locais de caracters,
                                 //         separação decimal, etc

    std::string line;

    std::getline(file, line); // pula cabeçalho

    while (std::getline(file, line)) {
        auto cols = splitTSV(line);

        auto id = BookId::create(cols[0]);
        std::string titulo = cols[1];
        std::string subtitulo = cols[2];
        std::string autores = cols[3];
        std::string assunto = cols[4];
        std::string colecao = cols[5];
        int copias;
        try {
            copias = std::stoi(cols[6]);
        }
        catch (...) {
            copias = 1;
        }
            

        if (!id) {
            return std::unexpected(id.error());
        }

        Book b(id.value(), titulo, subtitulo, autores, assunto, colecao, copias);
        auto result = serv.cadastrarLivro(b);

        if (!result) {
            return std::unexpected(result.error());
        }
    }

    return {};
}




====================
// ARQUIVO: .\infra\feed\feed.h
====================
﻿#pragma once

#include "../../application/LibService.h"

ECM::Result db_feed(LibService& serv);



====================
// ARQUIVO: .\infra\repositories\BookRepository.cpp
====================
﻿#include "BookRepository.h"
#include "../db/database.h"
#include <iostream> // seria interessante tirar isso daqui

BookRepository::BookRepository(Database& db) : db(db) {}

ECM::Result BookRepository::salvar(const Book& livro) {
    auto prep = db.prepare(R"(
        INSERT INTO livros (id, titulo, subtitulo, autor, assunto, isbn)
        VALUES (?, ?, ?, ?, ?, ?)
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error()); 
    }

    auto& stmt = prep.value();
    

    stmt->bind(1, livro.id.get_Id_int());
    stmt->bind(2, livro.titulo);
    stmt->bind(3, livro.subtitulo);
    stmt->bind(4, livro.autor);
    stmt->bind(5, livro.assunto);
    stmt->bind(6, livro.isbn);

    return stmt->step();
}

ECM::Expected<Book> BookRepository::getBook(const BookId id) {
    auto prep = db.prepare(R"(
        SELECT titulo, subtitulo, autor, assunto, colecao, isbn FROM livros
        WHERE id = ?;
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, id.get_Id_int());

    auto res = stmt->step();

    if (res.has_value()) {
        if (stmt->hasRow()) {
            std::string titulo = stmt->columnText(0);
            std::string subtitulo = stmt->columnText(1);
            std::string autor = stmt->columnText(2);
            std::string assunto = stmt->columnText(3);
            std::string colecao = stmt->columnText(4);
            Book b = Book(id, titulo, subtitulo, autor, assunto, colecao, 1);
            return b;
        }
        return std::unexpected(notFound("Livro não encontrado!"));
    }

    return std::unexpected(res.error());
}



====================
// ARQUIVO: .\infra\repositories\BookRepository.h
====================
﻿#pragma once

#include "../../core/entities/Book.h"
#include "../db/database.h"
#include "../../core/errors/errors.h"

class BookRepository {
private:
    Database& db;
public:
    explicit BookRepository(Database& db);
    ECM::Result salvar(const Book& u); 
    ECM::Expected<Book> getBook(const BookId id);
};
 


====================
// ARQUIVO: .\infra\repositories\ItemRepository.cpp
====================
﻿#include "ItemRepository.h"
#define NOMINMAX
#include<iostream>
#include <windows.h>
#include <string>

ItemRepository::ItemRepository(Database& db) : db(db) {}


ECM::Result ItemRepository::buscarId(const ItemId& id) {

    auto prep = db.prepare(R"(
        SELECT id FROM itens 
        WHERE id = ?
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, id.get_Id());

    
        auto res = stmt->step();
        if (!res) return std::unexpected(res.error());
        if (!stmt->hasRow()) return std::unexpected(notFound("Item não encontrado"));
        return {};
}

ECM::Result ItemRepository::salvar(const Book& b, int past, int n) {
    auto prep = db.prepare(R"(
        INSERT INTO itens (id, book_id)
        VALUES (?, ?)
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    past = past + 1;

    for (int i = past; i < past + n; i++) {

        std::string itemId = b.id.get_Id_format() + "-" + Book::get_Item(i);

        stmt->bind(1, itemId);
        stmt->bind(2, b.id.get_Id_int());

        auto res = stmt->step();
        if (!res.has_value()) return res;
        stmt->reset();
    }

    return {};
}


ECM::Expected<int> ItemRepository::maxId(const BookId& id) {
    auto prep = db.prepare(R"(
        SELECT id FROM itens 
        WHERE book_id = ?
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, id.get_Id_int());

    int max_ex = 0;

    while (true) {
        auto res = stmt->step();
        if (!res) return std::unexpected(res.error());
        if (!stmt->hasRow()) break;

        auto idTest = ItemId::create(stmt->columnText(0));
        if (!idTest) {
            return std::unexpected(addContext(idTest.error(), "Não foi possível identificar o número de exemplares, um dos ids está inválido."));
        }
        max_ex = std::max(max_ex, idTest.value().getExemp());
    }

    return max_ex;
}

ECM::Expected<int> ItemRepository::quantosDisponiveis(const BookId& book) {
    std::cout << "Entra aqui" << std::endl;
    system("pause");
    auto prep = db.prepare(
        R"(SELECT COUNT(*)
        FROM itens i
        WHERE i.book_id = ?
        AND NOT EXISTS(
            SELECT 1 FROM loans l
            WHERE l.item_id = i.id
            AND l.status != 0
        );)"
     );

    if (!prep) {
        return std::unexpected(prep.error());
    }
    
    auto& stmt = prep.value();
    stmt->bind(1, book.get_Id_int());

    auto res = stmt->step();
    if (!res) {
        return std::unexpected(res.error());
    }
   
    return stmt->columnInt(0);
}


ECM::Expected<int> ItemRepository::quantosLivros(const BookId& book) {

    auto prep = db.prepare(
        R"(SELECT COUNT(*)
        FROM itens i
        WHERE i.book_id = ?;)"
    );

    if (!prep) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();
    stmt->bind(1, book.get_Id_int());


    auto res = stmt->step();
    if (!res) {
        return std::unexpected(res.error());
    }

    return stmt->columnInt(0);
}




====================
// ARQUIVO: .\infra\repositories\ItemRepository.h
====================
﻿#pragma once

#include "../../core/entities/Book.h"
#include "../../core/entities/Item.h"
#include "../../core/errors/errors.h"
#include "../db/database.h"

class ItemRepository {
private:
    Database& db;
public:
    explicit ItemRepository(Database& db);
    ECM::Result salvar(const Book& u, int past, int n); 
    ECM::Expected<int> maxId(const BookId& id);
    ECM::Result buscarId(const ItemId& id);
    ECM::Expected<int> quantosDisponiveis(const BookId& book);
    ECM::Expected<int> quantosLivros(const BookId& book);
};




====================
// ARQUIVO: .\infra\repositories\LoanRepository.cpp
====================
﻿#include "LoanRepository.h"
#include "../db/database.h"
#include "../../core/utils/TimeUtils.h"

LoanRepository::LoanRepository(Database& db) : db(db) {}

ECM::Result LoanRepository::salvar(const Loan& l) {
    auto prep = db.prepare(R"(
        INSERT INTO loans (item_id, user_id, loaned_at, due_at, status)
        VALUES (?, ?, ?, ?, ?);
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, l.item_id.get_Id());
    stmt->bind(2, l.user_id.get_Id_raw());
    stmt->bind(3, timeToString(l.loaned_at));
    stmt->bind(4, timeToString(l.due_at));
    stmt->bind(5, static_cast<int>(LoanStatus::Ativo)); 

    return stmt->step();
}
    
ECM::Expected<LoanState> LoanRepository::getLoanState(const UserId& user, const ItemId& item) {
    auto prep = db.prepare(R"(
        SELECT id, status, due_at, n_Renov, returned_at FROM loans 
        WHERE user_id = ? AND item_id = ? AND status != 0;
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, user.get_Id_raw());
    stmt->bind(2, item.get_Id());

    auto res = stmt->step();

    if (res.has_value()) {
        if (stmt->hasRow()) {
            int id = stmt->columnInt(0);
            LoanStatus status = Loan::parseLoanStatus(stmt->columnInt(1));
            auto due_at = parseDate(stmt->columnText(2));
            int n_Renov = stmt->columnInt(3);
            std::string returned_at = stmt->columnText(4);
            if (returned_at.empty() && status == LoanStatus::Devolvido) {
                return std::unexpected(unknown("Dados Inconsistentes!"));
            }
            if (returned_at.empty()) {
                return LoanState{ id, status, due_at, n_Renov, std::nullopt };
            }
            return LoanState{ id, status, due_at, n_Renov, parseDate(returned_at)};
        }
        return std::unexpected(notFound("Empréstimo não encontrado!"));
    }

    return std::unexpected(res.error());
}



ECM::Result LoanRepository::realizarDevolucao(int loanId) {
    auto prep = db.prepare("UPDATE loans SET returned_at = ?, status = 0 WHERE id = ?;");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();
    
    auto agora = today();
    stmt->bind(1, timeToString(agora));
    stmt->bind(2, loanId);

    return stmt->step();
}

ECM::Result LoanRepository::renovar(int loanId, int prazoDias) {

    // 1. Busca número atual de renovações
    auto prepSelect = db.prepare(
        "SELECT n_Renov FROM loans WHERE id = ?;"
    );

    if (!prepSelect) {
        return std::unexpected(prepSelect.error());
    }

    auto& stmtSelect = prepSelect.value();
    stmtSelect->bind(1, loanId);

    auto res = stmtSelect->step();
    if (!res) {
        return std::unexpected(res.error());
    }

    if (!stmtSelect->hasRow()) {
        return std::unexpected(notFound("Empréstimo não encontrado."));
    }

    int n_Renov = stmtSelect->columnInt(0);

    // 2. Calcula nova data de vencimento
    auto hoje = today();
    std::chrono::year_month_day novoVencimento =
        std::chrono::sys_days(hoje) + std::chrono::days(prazoDias);

    // 3. Atualiza empréstimo
    auto prepUpdate = db.prepare(
        "UPDATE loans SET due_at = ?, n_Renov = ? WHERE id = ?;"
    );

    if (!prepUpdate) {
        return std::unexpected(prepUpdate.error());
    }

    auto& stmtUpdate = prepUpdate.value();
    stmtUpdate->bind(1, timeToString(novoVencimento));
    stmtUpdate->bind(2, n_Renov + 1);
    stmtUpdate->bind(3, loanId);

    return stmtUpdate->step();
}

ECM::Result LoanRepository::temEmprestimo(const UserId& user, const BookId& book) {
    auto prep = db.prepare(
        "SELECT 1 FROM loans l JOIN itens i ON l.item_id = i.id WHERE l.user_id = ? AND l.status !=0 AND i.book_id = ? LIMIT 1;"
    );

    if (!prep) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();
    stmt->bind(1, user.get_Id_int());
    stmt->bind(2, book.get_Id_int());


    auto res = stmt->step();
    if (!res) {
        return std::unexpected(res.error());
    }

    if (stmt->hasRow()) {
        return std::unexpected(conflict("O usuário já possui empréstimo ativo neste título"));
    }

    return {};
}

ECM::Expected<std::vector<std::chrono::year_month_day>> LoanRepository::datasPrevistasPorLivro(const BookId& book) {
    auto prep = db.prepare(R"(
        SELECT l.due_at
            FROM loans l
            JOIN itens i ON i.id = l.item_id
            WHERE i.book_id = ?
            AND l.status != 0
            ORDER BY l.due_at ASC;
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, book.get_Id_int());

    std::vector<std::chrono::year_month_day> results;

    while (true) {
        auto res = stmt->step();
        if (!res) return std::unexpected(res.error());
        if (!stmt->hasRow()) break;

        results.push_back(parseDate(stmt->columnText(0)));
    }

    return results;

    
}

ECM::Expected<int> LoanRepository::ativosPorUser(const UserId& user_id) {
    auto prep = db.prepare(R"(SELECT COUNT(*)
                                FROM loans l 
                                WHERE l.user_id = ? AND l.status > 0)");


    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, user_id.get_Id_int());

    auto res = stmt->step();

    if (!res) return std::unexpected(res.error());

    return stmt->columnInt(0);
}


====================
// ARQUIVO: .\infra\repositories\LoanRepository.h
====================
﻿#pragma once

#include "../../core/entities/Loan.h"
#include "../db/database.h"

class LoanRepository {
private:
    Database& db;
public:
    explicit LoanRepository(Database& db);
    ECM::Result salvar(const Loan& u);
    ECM::Expected<LoanState> getLoanState(const UserId& user, const ItemId& item);
    ECM::Result temEmprestimo(const UserId&, const BookId&);
    ECM::Result realizarDevolucao(int loanId);
    ECM::Result renovar(int loanId, int limit);
    ECM::Expected<std::vector<std::chrono::year_month_day>> datasPrevistasPorLivro(const BookId& bookId);
    ECM::Expected<int> ativosPorUser(const UserId& id);

};





====================
// ARQUIVO: .\infra\repositories\ReservaRepository.cpp
====================
﻿#include "ReservaRepository.h"
#include "../../core/utils/TimeUtils.h"

ReservaRepository::ReservaRepository(Database& db) : db(db) {}

ECM::Result ReservaRepository::inserir(const Reserva& r) {
    auto prep = db.prepare(R"(
        INSERT INTO reservas (user_id, book_id, data_reserva, status)
        VALUES (?, ?, ?, ?)
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, r.getUser().get_Id_int());
    stmt->bind(2, r.getBook().get_Id_int());
    stmt->bind(3, timeToString(today()));
    stmt->bind(4, static_cast<int>(r.getStatus()));

    auto res = stmt->step();

    if (!res) {
        return std::unexpected(addContext(res.error(), "Erro ao inserir reserva: "));
    }

}

ECM::Result ReservaRepository::usuarioJaReservou(const UserId& user, const BookId& book) {
    auto prep = db.prepare(R"(
        SELECT 1 FROM reservas WHERE user_id = ? AND book_id = ? AND status = 1 LIMIT 1;
    )");

    if (!prep.has_value()) {
        return std::unexpected(addContext(prep.error(), "Não foi possível verificar se o usuário possui reservas ativas no mesmo título: "));
    }

    auto& stmt = prep.value();

    stmt->bind(1, user.get_Id_int());
    stmt->bind(2, book.get_Id_int());

    auto res = stmt->step();

    if (res.has_value()) {
        if (stmt->hasRow()) {
            return std::unexpected(conflict("Usuário já reservou este título!"));
        }
        return {};
    }
    return std::unexpected(addContext(res.error(), "Não foi possível verificar se o usuário possui reservas ativas no mesmo título: "));
}

ECM::Expected<int> ReservaRepository::ativasPorLivro(const BookId& book) {
    auto prep = db.prepare(R"(
        SELECT COUNT(*)
        FROM reservas
        WHERE book_id = ?
        AND status = 1;
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, book.get_Id_int());

    auto res = stmt->step();

    if (res.has_value()) {
        return stmt->columnInt(0);
    }
    return std::unexpected(res.error());
    
}

ECM::Expected<ReservaInfo> ReservaRepository::proximaReserva(const BookId& book) {
    auto prep = db.prepare(R"(SELECT r.id, m.id, m.nome, l.titulo
                                FROM reservas r 
                                JOIN membros m ON r.user_id = m.id
                                JOIN livros l ON r.book_id = l.id
                                WHERE r.book_id = ? AND r.status > 0 
                                ORDER BY r.data_reserva ASC LIMIT 1)");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, book.get_Id_int());

    auto res = stmt->step();

    if (!res) {
        return std::unexpected(res.error());
    }
     

    if (stmt->hasRow()) {
        ReservaInfo info = { stmt->columnInt(0), stmt->columnInt(1), stmt->columnText(2), stmt->columnText(3)};
        return info;
    }
    return std::unexpected(notFound(""));
}

ECM::Result ReservaRepository::updateStatus(int id, ReservaStatus status) {
    int intStatus = static_cast<int>(status);
    auto prep = db.prepare(R"(UPDATE reservas SET status = ? WHERE id = ?)");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, intStatus);
    stmt->bind(2, id);

    auto res = stmt->step();

    if (!res) {
        return std::unexpected(res.error());
    }

    return {};
}

ECM::Expected<std::vector<ReservaInfo>> ReservaRepository::listarAtivasPorUser(const UserId& user_id) {
    auto prep = db.prepare(R"(SELECT r.id, m.id, m.nome, l.titulo
                                FROM reservas r 
                                JOIN membros m ON r.user_id = m.id
                                JOIN livros l ON r.book_id = l.id
                                WHERE r.user_id = ? AND r.status > 0)");


    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, user_id.get_Id_int());

    std::vector<ReservaInfo> results;

    while (true) {
        auto res = stmt->step();
        if (!res) return std::unexpected(res.error());
        if (!stmt->hasRow()) break;

        ReservaInfo dto{
            .id_reserva = stmt->columnInt(0),
            .id_user = stmt->columnInt(1),
            .nome_user = stmt->columnText(2),
            .nome_livro = stmt->columnText(3)
        };

        results.push_back(std::move(dto));
    }

    return results;
}

ECM::Expected<int> ReservaRepository::ativasPorUser(const UserId& user_id) {
    auto prep = db.prepare(R"(SELECT COUNT(*)
                                FROM reservas r 
                                WHERE r.user_id = ? AND r.status > 0)");


    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, user_id.get_Id_int());

    auto res = stmt->step();
    
    if (!res) return std::unexpected(res.error());

    return stmt->columnInt(0);
}




====================
// ARQUIVO: .\infra\repositories\ReservaRepository.h
====================
﻿#pragma once

#include "../../core/dto/ReservaInfo.h"
#include "../../core/entities/Reserva.h"
#include "../db/database.h"


class ReservaRepository {
private:
	Database& db;
public:
	ReservaRepository(Database& db);

	ECM::Result inserir(const Reserva&);

	ECM::Result usuarioJaReservou(const UserId&, const BookId&);

	ECM::Expected<int> ativasPorLivro(const BookId& book);

	ECM::Expected<ReservaInfo> proximaReserva(const BookId&);

	ECM::Result updateStatus(int id, ReservaStatus status);

	ECM::Expected<std::vector<ReservaInfo>> listarAtivasPorUser(const UserId&);

	ECM::Expected<int> ativasPorUser(const UserId& user_id);

	//ECM::Expected<std::vector<Reserva>> listarAtivasPorLivro(const BookId&);


};



====================
// ARQUIVO: .\infra\repositories\SearchRepository.cpp
====================
﻿#include "SearchRepository.h"

SearchRepository::SearchRepository(Database& db) : db(db) {}

ECM::Expected<std::vector<BookSearchResult>> 
	SearchRepository::searchBooks(std::string_view s, BookSearchField option) {
	std::string query = R"(SELECT 
  b.id,
  b.titulo,
  b.subtitulo,
  b.autor,

  COUNT(i.id) AS total_items,

  SUM(CASE 
        WHEN l.id IS NULL THEN 1 
        ELSE 0 
      END) AS available,

  SUM(CASE 
        WHEN l.id IS NOT NULL THEN 1 
        ELSE 0 
      END) AS loaned

FROM livros b
JOIN itens i 
  ON i.book_id = b.id

LEFT JOIN loans l 
  ON l.item_id = i.id 
 AND l.returned_at IS NULL

WHERE )";

    switch (option) {
    case BookSearchField::Title:
        query += " b.titulo LIKE ? ";
        break;
    case BookSearchField::Author:
        query += " b.autor LIKE ? COLLATE NOCASE";
        break;
    default:
        query += " (b.titulo LIKE ? COLLATE NOCASE OR b.autor LIKE ? COLLATE NOCASE) ";
        break;
    }

    query += "GROUP BY b.id, b.titulo, b.autor;";

    auto prep = db.prepare(query);

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    std::string pattern = "%" + std::string(s) + "%";

    if ((option == BookSearchField::Author)||(option == BookSearchField::Title)) {
        stmt->bind(1, pattern);
    }
    else {
        stmt->bind(1, pattern);
        stmt->bind(2, pattern);
    }

    std::vector<BookSearchResult> results;

    while (true) {
        auto res = stmt->step();
        if (!res) return std::unexpected(res.error());
        if (!stmt->hasRow()) break;

        BookSearchResult dto{
            .book_id = BookId::fromDatabase(stmt->columnInt(0)),
            .title = stmt->columnText(1),
            .subtitle = stmt->columnText(2),
            .author = stmt->columnText(3),
            .total_items = stmt->columnInt(4),
            .available = stmt->columnInt(5),
            .loaned = stmt->columnInt(6)
        };

        results.push_back(std::move(dto));
    }

    return results;

}

ECM::Expected<std::vector<UserSearchResult>>
SearchRepository::searchUser(std::string_view term) {
    std::string query = R"(SELECT 
  id,
  nome

FROM membros 

WHERE nome LIKE ? COLLATE NOCASE)";


    auto prep = db.prepare(query);

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    std::string pattern = "%" + std::string(term) + "%";

    stmt->bind(1, pattern);

    std::vector<UserSearchResult> results;

    while (true) {
        auto res = stmt->step();
        if (!res) return std::unexpected(res.error());
        if (!stmt->hasRow()) break;

        UserSearchResult dto{
            .user_id = UserId::fromDatabase(stmt->columnInt(0)),
            .nome = stmt->columnText(1)
        };

        results.push_back(std::move(dto));
    }

    return results;

}

ECM::Expected<std::vector<UserSearchResult>>
SearchRepository::searchUser(int term) {
    std::string query = R"(SELECT 
  id,
  nome

FROM membros 

WHERE id LIKE ?)";

    auto prep = db.prepare(query);

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, term);

    std::vector<UserSearchResult> results;

    while (true) {
        auto res = stmt->step();
        if (!res) return std::unexpected(res.error());
        if (!stmt->hasRow()) break;

        UserSearchResult dto{
            .user_id = UserId::fromDatabase(stmt->columnInt(0)),
            .nome = stmt->columnText(1)
        };

        results.push_back(std::move(dto));
    }

    return results;

}


====================
// ARQUIVO: .\infra\repositories\SearchRepository.h
====================
﻿#pragma once

#include "../../core/errors/errors.h"
#include "../../core/dto/BookSearchResult.h"
#include "../../core/dto/UserSearchResult.h"
#include "../../core/BookSearchField.h"
#include "../../core/UserSearchField.h"
#include "../db/database.h"

class SearchRepository {
public:
	SearchRepository(Database& db);
	ECM::Expected<std::vector<BookSearchResult>>
		searchBooks(std::string_view term, BookSearchField field);
	ECM::Expected<std::vector<UserSearchResult>>
		searchUser(std::string_view term);
	ECM::Expected<std::vector<UserSearchResult>>
		searchUser(int id);
private:
	Database& db;
};


====================
// ARQUIVO: .\infra\repositories\UserRepository.cpp
====================
#include "UserRepository.h"
#include "../db/database.h"
#include <chrono>


UserRepository::UserRepository(Database& db) : db(db) {}

ECM::Result UserRepository::salvar(const User& u) {
    auto prep = db.prepare(R"(
        INSERT INTO membros (id, nome, email, tel, role)
        VALUES (?, ?, ?, ?, ?)
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, u.id.get_Id_int());
    stmt->bind(2, u.nome);
    stmt->bind(3, u.email.get());
    stmt->bind(4, u.tel);
    stmt->bind(5, 1); //TODO: consertar essa parte de roles 

    auto res = stmt->step();

    if (!res) {
        return std::unexpected(addContext(res.error(), "Erro ao salvar usuário: "));
    }

    return {};
}

ECM::Result UserRepository::update(const User& u) {
    auto prep = db.prepare(R"(
        UPDATE users SET nome = ?, email = ?, tel = ? WHERE id = ?
    )");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    
    stmt->bind(1, u.nome);
    stmt->bind(2, u.email.get());
    stmt->bind(3, u.tel); 
    // TODO: colocar possibilidade de alterar role
    stmt->bind(4, u.id.get_Id_int());
    

    auto res = stmt->step();

    if (!res) {
        return std::unexpected(addContext(res.error(), "Erro ao atualizar usuário: "));
    }

    return {};
}

ECM::Expected<UserState> UserRepository::getUserState(const UserId& id) {
    auto prep = db.prepare(R"(SELECT status, role, blocked_until FROM membros WHERE id = ?)");

    if (!prep.has_value()) {
        return std::unexpected(prep.error());
    }

    auto& stmt = prep.value();

    stmt->bind(1, id.get_Id_int());

    ECM::Result res = stmt->step();

    if (!res.has_value()) {
        return std::unexpected(res.error());
    }

    if (!stmt->hasRow()) {
        return std::unexpected(notFound("Usuário não encontrado!"));
    }
    int status = stmt->columnInt(0);

    if (status == 2) {
        std::string blocked_until = stmt->columnText(2);
        if (blocked_until.empty()) {
            return UserState{ UserStatus::Bloqueado};
        }
        return UserState{ UserStatus::Bloqueado, User::parseUserRole(stmt->columnInt(1)) , parseDate(blocked_until)};
    }
    if (status == 0) {
        return UserState{ UserStatus::Inativo,  User::parseUserRole(stmt->columnInt(1)), std::nullopt };
    }
    if (status == 1) {
        return UserState{ UserStatus::Ativo,  User::parseUserRole(stmt->columnInt(1)), std::nullopt };
    }
    return std::unexpected(unknown("Erro desconhecido."));
}


 ECM::Result UserRepository::block(UserId id, std::chrono::days atraso) { 
     auto check = db.prepare(R"(SELECT blocked_until FROM membros WHERE id = ?)");

     if (!check.has_value()) {
         return std::unexpected(check.error()); 
     }

     auto& stmt = check.value();

     stmt->bind(1, id.get_Id_int());

     auto res = stmt->step();

     if (!res) {
         return std::unexpected(addContext(res.error(), "Não foi possível buscar até quando usuário encontra-se bloqueado: "));
     }

     std::string blockString = stmt->columnText(0);

     std::chrono::year_month_day block = today();

     if (!blockString.empty()) {
         block = parseDate(blockString);
     }

     auto prep = db.prepare(R"(UPDATE membros SET status = 2, blocked_until = ? WHERE id = ?)");

     if (!prep.has_value()) {
         return std::unexpected(prep.error()); 
     }

     auto& stmt2 = prep.value();

     block = std::chrono::sys_days(block) + atraso;

     stmt2->bind(1, timeToString(block));
     stmt2->bind(2, id.get_Id_int());

     return (stmt2->step());
 }

 ECM::Expected<User> UserRepository::getUser(const UserId& user) {
     auto prep = db.prepare(R"(
        SELECT id, nome, email, tel, status, blocked_until FROM membros
        WHERE id = ?;
    )");

     if (!prep.has_value()) {
         return std::unexpected(prep.error());
     }
     

     auto& stmt = prep.value();

     stmt->bind(1, user.get_Id_int());
     
     auto res = stmt->step();

     if (res.has_value()) {
         if (stmt->hasRow()) {
             UserId id = UserId::fromDatabase(stmt->columnInt(0));
             std::string nome = stmt->columnText(1);
             Email email = Email::fromDatabase(stmt->columnText(2));
             std::string tel = stmt->columnText(3);
             UserStatus status = User::parseUserStatus(stmt->columnInt(4));

             std::optional<std::chrono::year_month_day> blocked_until;
             if (stmt->columnText(5).empty()) {
                 blocked_until = std::nullopt;
             }
             else {
                 blocked_until = parseDate(stmt->columnText(5));
             }
             User u = User(id, nome, email, tel, status, blocked_until);
             return u;
         }
         return std::unexpected(notFound("Usuário não encontrado!"));
     }

     return std::unexpected(res.error());
 }


====================
// ARQUIVO: .\infra\repositories\UserRepository.h
====================
#pragma once

#include "../../core/entities/User.h"
#include "../db/database.h"

#include "../../core/utils/TimeUtils.h"

class UserRepository {
private:
    Database& db;
public:
    explicit UserRepository(Database& db);
    ECM::Result salvar(const User& u);
    ECM::Result update(const User& u);
    ECM::Expected<UserState> getUserState(const UserId& id);
    ECM::Result block(UserId id, std::chrono::days atraso);
    ECM::Expected<User> getUser(const UserId& user);
};




====================
// ARQUIVO: .\ui\controller\MenuOutros.cpp
====================
﻿#include "MenuOutros.h"
#include "../utils/exibirSelecao.h"
#include "../screens/CadastrarLivro.h"
#include "../screens/BuscarUsuario.h"
#include "../screens/BuscaLivro.h"
#include "../screens/BuscarReservas.h"

void menuOutros(LibService& service){
    
    std::array<std::string, 5> opcoes = {
        "Cadastrar novo livro",
        "Buscar um livro",
        "Buscar usuário",
        "Buscar reservas",
        "Voltar"
    };


    while (true) {
        clearScreen();
        std::cout << "Biblioteca Edvaldo Cardoso Mattos\nPrimeira Igreja Batista em Taboão da Serra\n\n";
        int escolha = exibirSelecao(opcoes);

        switch (escolha) {
        case 0:
            cadastrarLivro(service);
            break;
        case 1:
            BuscaLivro(service);
            break;
        case 2:
            BuscarUsuario(service);
            break;
        case 3:
            BuscarReservas(service);
            break;
        case 4:
            return;
        }
    }
}


====================
// ARQUIVO: .\ui\controller\MenuOutros.h
====================
﻿#pragma once

#include "../../application/LibService.h"


void menuOutros(LibService& service);



====================
// ARQUIVO: .\ui\controller\MenuPrincipal.cpp
====================
﻿#include "MenuPrincipal.h"
#include "MenuOutros.h"

#include "../screens/CadastrarUsuario.h"
#include "../screens/RegistrarEmprestimo.h"
#include "../screens/RegistrarDevolucao.h"
#include "../screens/renovacao.h"
#include "../utils/exibirSelecao.h"

#include "../../devtools/main_dev.h"

#include <array>
#include <string>

#include <iostream>

void MenuPrincipal(LibService& serv) {
    std::array<std::string, 6> menuPrincipal = {
        "Registrar empréstimo",
        "Registrar devolução",
        "Renovar empréstimo",
        "Cadastrar novo usuário",
        "Outros",
        "Sair"
    };
 

    while (true) {
        clearScreen();
        std::cout << "Biblioteca Edvaldo Cardoso Mattos\nPrimeira Igreja Batista em Taboão da Serra\n\n";
        int escolha = exibirSelecao(menuPrincipal);

        switch (escolha) {
        case 0:
            registrarEmprestimo(serv);
            break;
        case 1:
            registrarDevolucao(serv);
            break;
        case 2:
            renovacao(serv);
            break;
        case 3:
            cadastrarUsuario(serv);
            break;
        case 4:
            menuOutros(serv);
            break;
        case -1:
            main_dev(serv);
            break;
        case 5:
            return; // encerra o programa
        }
    }
}



====================
// ARQUIVO: .\ui\controller\MenuPrincipal.h
====================
﻿#pragma once

#include "../../application/LibService.h"

#include "../../infra/repositories/UserRepository.h"
#include "../../infra/repositories/BookRepository.h"
#include "../../infra/repositories/ItemRepository.h"
#include "../../infra/repositories/LoanRepository.h"


void MenuPrincipal(LibService& serv);



====================
// ARQUIVO: .\ui\forms\Form.cpp
====================
﻿#include "Form.h"
#include "../terminal/Terminal.h"
#include "../terminal/InputUtils.h"
#include "../utils/exibirSelecao.h"
#include <iostream>

void Form::add(std::unique_ptr<IField> field) {
    fields.push_back(std::move(field));
}

const std::string& Form::get(int i) const {
    return fields[i]->value();
}

bool Form::run() {
    while (true) {
        clearScreen();
        draw();

        std::string input = lerTexto();

        if (input == "$cancelar") return false;

        if (input == "$voltar") {
            if (current > 0) current--;
            continue;
        }

        std::string error;
        if (!fields[current]->handleInput(input, error)) {
            showError(error);
            continue;
        }

        if (current == fields.size() - 1) {
            if (confirm()) return true;
        }
        else {
            current++;
        }
    }
}

void Form::draw() {
    std::cout << "===== " << title << " =====\n\n";

    for (int i = 0; i < fields.size(); ++i) {
        std::cout << (i == current ? "\033[47;30m> " : "  ");
        std::cout << fields[i]->label() << ": " << fields[i]->value() << "\033[0m\n";
    }

    std::cout << "\nComandos: $voltar  $cancelar\n\n";
    std::cout << fields[current]->label() << ": ";
}

void Form::showError(const std::string& msg) const {
    std::cout << "\nERRO: " << msg << "\n";
    system("pause");
}

bool Form::confirm() const {
    clearScreen();
    std::cout << "========== Confirmar dados ==========\n\n";

    for (const auto& f : fields) {
        std::cout << f->label() + ": " + f->value() + "\n";
    }

    std::array<std::string, 2> opcoes = { "Sim", "Não" };
    std::cout << "\nConfirmar?\n";
    int sel = exibirSelecao(opcoes);
    return (sel == 0);
}



====================
// ARQUIVO: .\ui\forms\Form.h
====================
﻿#pragma once
#include <string>
#include <vector>
#include <functional>
#include "../../core/errors/errors.h"

inline ECM::Expected<std::string> accept_any(const std::string& s) {
    return s;
}

inline ECM::Expected<int> int_validator(const std::string& s) {
    if (s.empty()) {
        return std::unexpected(validation("Id vazio!"));
    }
    for (char c : s) {
        if (!std::isdigit(static_cast<unsigned char>(c))) {
            return std::unexpected(validation("Foram inseridos caracteres inválidos!"));
        }
    }
    return std::stoi(s);
}

struct IField {
    virtual ~IField() = default;
    virtual const std::string& label() const = 0;
    virtual const std::string& value() const = 0;
    virtual bool handleInput(const std::string& input, std::string& error) = 0;
};

template <class T>
struct Field : IField {
    std::string _label;
    std::string _value;

    std::function<ECM::Expected<T>(const std::string&)> validator;
    std::optional<T> parsed;

    Field(std::string label,
        std::function<ECM::Expected<T>(const std::string&)> validator)
        : _label(std::move(label)), validator(std::move(validator)) {
    }

    const std::string& label() const override { return _label; }
    const std::string& value() const override { return _value; }

    void set(const std::string& raw, const T& value) {
        _value = raw;
        parsed = value;
    }

    bool handleInput(const std::string& input, std::string& erro) override {
        if (input.empty() && parsed.has_value()) {
            return true;
        }

        auto res = validator(input);
        if (!res.has_value()) {
            erro = res.error().message;
            return false;
        }
        _value = input;
        parsed = res.value();
        return true;
    }

    const T& get() const { return parsed.value(); }
};


class Form {
public:
    Form(std::string title, std::vector<std::unique_ptr<IField>> fields);

    explicit Form(std::string title)
        : title(std::move(title)) {
    }

    // true = confirmado | false = cancelado
    bool run();

    const std::string& get(int i) const;

    void add(std::unique_ptr<IField> field);

private:
    std::string title;
    std::vector<std::unique_ptr<IField>> fields;
    int current = 0;

    void draw();
    void showError(const std::string& msg) const;
    bool confirm() const;
};



====================
// ARQUIVO: .\ui\input\LoanInput.cpp
====================
﻿#include "LoanInput.h"
#include "../terminal/InputUtils.h"

#include <iostream>


ECM::Expected<LoanInput> lerUserEItem() {
    std::string inputUser;
    std::string inputItem;
    std::cout << "Escaneie ou digite o ID do usuário: ";
    inputUser = lerTexto();

    // o comportamente esperado é que o usuário do programa insira primeiro o ID do usuário da biblioteca
    // e somente depois o ID do item, mas atualmente essa função tenta ser inteligente e captar quando a 
    // ordem foi trocada
    // TODO: acrescentar um método na LibService que checa os requisitos para um usuário pegar um livro 
    // emprestado e colocar aqui, de forma que o sistem nem peça o ID do item
    auto userTest = UserId::create(inputUser);
    auto itemTest = ItemId::create(inputUser);

    if (!userTest.has_value()) {
        if (!itemTest.has_value()) {
            std::cout << userTest.error().message << std::endl;
            return std::unexpected(userTest.error());
        }
        else {
            std::cout << "Você digitou o ID do livro!\n";
            std::cout << "Agora, escaneie ou digite o ID do usuário: ";
            inputUser = lerTexto();
            userTest = UserId::create(inputUser);
            if (!userTest.has_value()) {
                std::cout << userTest.error().message << std::endl;
                return std::unexpected(userTest.error());
            }
        }
    }
    else {
        std::cout << "Agora, escaneie ou digite o ID do livro: ";
        inputItem = lerTexto();
        itemTest = ItemId::create(inputItem);
        if (!itemTest.has_value()) {
            std::cout << itemTest.error().message << std::endl;
            return std::unexpected(itemTest.error());
        }
    }

    return LoanInput{ userTest.value(), itemTest.value() };
}


====================
// ARQUIVO: .\ui\input\LoanInput.h
====================
﻿#pragma once

#include "../../core/ids/UserId.h"
#include "../../core/ids/ItemId.h"



struct LoanInput {
    UserId user;
    ItemId item;
};

ECM::Expected<LoanInput> lerUserEItem();



====================
// ARQUIVO: .\ui\screens\AddItem.cpp
====================
﻿#include "AddItem.h"
#include <iostream>
#include "../terminal/InputUtils.h"


void addItem(LibService& serv, BookId& id) {
    std::cout << "Quantos exemplares você gostaria de adicionar? ";
	std::string s = lerTexto();
    bool isValid = true;
    for (int i = 0; i < s.size(); i++) {
        isValid = isValid && std::isdigit(static_cast<unsigned char>(s[i]));
        if (!isValid) {
            std::cout << "Caracteres inválidos inseridos! \n" << std::endl;
            addItem(serv, id);
            break;
        }
    }
    if (isValid) {
        int n = std::stoi(s);
        auto result = serv.adicionarItem(id, n);
        if (!result) {
            std::cout << result.error().message << std::endl;
        }
        else {
            std::cout << "Itens adicionado com sucesso!" << std::endl;
        }
        system("pause");
    }
}


====================
// ARQUIVO: .\ui\screens\AddItem.h
====================
﻿#pragma once

#include "../../application/LibService.h"

#include <string>

void addItem(LibService& serv, BookId& id);



====================
// ARQUIVO: .\ui\screens\AlterarUsuario.cpp
====================
﻿#include "AlterarUsuario.h"
#include "../forms/Form.h"
#include <iostream>

void AlterarUsuario(LibService& serv, User u){

    auto nomeField = std::make_unique<Field<std::string>>(
        "Nome",
        [](const std::string& input) -> ECM::Expected<std::string> {
            if (!input.empty()) {
                return input;
            }
            return std::unexpected(validation("Nome não pode ser vazio!"));
        });

    auto emailField = std::make_unique<Field<Email>>("E-mail", Email::create);

    auto telField = std::make_unique<Field<std::string>>(
        "Telefone",
        [](const std::string& input) -> ECM::Expected<std::string> {
            if (!input.empty()) {
                return input;
            }
            return std::unexpected(validation("Nome não pode ser vazio!"));
        }
    );

    
    nomeField->set(u.nome, u.nome);
    emailField->set(u.email.get(), u.email);
    telField->set(u.tel, u.tel);

    auto* nomePtr = nomeField.get();
    auto* emailPtr = emailField.get();
    auto* telPtr = telField.get();

    Form form("Alterar Usuário");

    std::cout << "ID do usuário: " << u.id.get_Id_format() << std::endl;
    form.add(std::move(nomeField));
    form.add(std::move(emailField));
    form.add(std::move(telField));

    if (!form.run()) return;

    User atualizado(
        u.id,
        nomePtr->get(),
        emailPtr->get(),
        telPtr->get()
    );

    auto res_update = serv.alterarUsuario(atualizado);
    if (!res_update) {
        std::cout << res_update.error().message;
    }
    else {
        std::cout << "Usuário atualizado com sucesso!" << std::endl;
    }
    system("pause");
    return;
}


====================
// ARQUIVO: .\ui\screens\AlterarUsuario.h
====================
﻿#pragma once

#include "../../application/LibService.h"
#include "../../core/errors/errors.h"

void AlterarUsuario(LibService& serv, User u);





====================
// ARQUIVO: .\ui\screens\BuscaLivro.cpp
====================
﻿#include "BuscaLivro.h"

#include "../utils/exibirSelecao.h"
#include "../terminal/terminal.h"
#include "../terminal/InputUtils.h"
#include "../utils/criarLinha.h"
#include "../../core/BookSearchField.h"
#include "Reservar.h"
#include "AddItem.h"

void BuscaLivro(LibService& serv){
	clearScreen();
	std::cout << "========== Busca por um livro ==========" << std::endl;
	std::cout << std::endl;
	std::cout << std::endl;
	std::cout << "Digite uma palavra ou expressão que deseja buscar: ";
	std::string s = lerTexto();
		clearScreen();
		std::cout << "Expressão a ser buscada: " + s + "\n\n\n" +
			"Você deseja procurar esta expressão entre os títulos ou nomes dos autores?\n";
		
		std::array<std::string, 3> opcoes = {
			"Ambos",
			"Título",
			"Autor"
		};
		
		int selecionada = exibirSelecao(opcoes);

	ECM::Expected<std::vector<BookSearchResult>> Resultado;
	
	switch (selecionada) {
	case 1:
		Resultado = serv.buscarLivros(s, BookSearchField::Title);
		break;
	case 2: 
		Resultado = serv.buscarLivros(s, BookSearchField::Author);
		break;
	default:
		Resultado = serv.buscarLivros(s, BookSearchField::TitleOrAuthor);
		break;
	}
	if (!Resultado) {
		std::cout << Resultado.error().message << std::endl;
		system("pause");
		return;
	}
	clearScreen();
	auto& res = Resultado.value();
	std::cout << "Foram encontrados " << res.size() << " resultados:" << std::endl;
	std::cout << std::endl;
	const int bsr_size = 6;
	std::array<int, bsr_size> sizes = { 6, 30, 25, 8, 10, 10 };
	std::array<std::string, bsr_size> line = {
		"ID",
		"Título",
		"Autor",
		"n. itens",
		"disponíveis",
		"emprestados"
	};
	auto labels = criarLinha(line, sizes);
	std::cout << "Resultados da busca: \n\n\n" + labels[0] + "\n" + labels[1] + "\n";
	std::string caput2;
	std::vector<std::string> out;
	for (int i = 0; i < res.size(); i++) {
		auto& bsr = res[i];
		std::array<std::string, bsr_size> strs = {
			bsr.book_id.get_Id_format(),
			bsr.title,
			bsr.author,
			std::to_string(bsr.total_items),
			std::to_string(bsr.available),
			std::to_string(bsr.loaned)
		};
		auto linha = criarLinha(strs, sizes);
		out.push_back(linha[0]);
		caput2 = caput2 + linha[0] + "\n" + linha[1] + "\n";
	}
	std::array<std::string, 3> escolha = { "Reservar um título", "Adicionar itens", "Voltar"};
	std::cout << caput2 + "\n\n O que você deseja fazer?\n" << std::endl;
	int input = exibirSelecao(escolha);
	int choice;
	switch (input) {
	case 0:
		clearScreen(); 
		choice = exibirSelecao("Qual livro você gostaria de reservar?\n\n\n  " + labels[0] + "\n" + labels[1], out, labels[1]);
		Reservar(serv, res[choice].book_id);
		break;
	case 1:
		clearScreen();
		choice = exibirSelecao("A qual livro você gostaria de adicionar itens?\n\n\n  " + labels[0] + "\n" + labels[1], out, labels[1]);
		addItem(serv, res[choice].book_id);
		break;
	default:
		break;
	}
}



====================
// ARQUIVO: .\ui\screens\BuscaLivro.h
====================
﻿#pragma once

#include "../../application/LibService.h"
#include <iostream>

void BuscaLivro(LibService& books);



====================
// ARQUIVO: .\ui\screens\BuscarReservas.cpp
====================
﻿#include "BuscarReservas.h"
#include "../terminal/InputUtils.h"
#include <iostream>
#include "../utils/exibirSelecao.h"

void BuscarReservas(LibService& serv) {
    clearScreen();
    std::string inputUser;
    std::string inputItem;
    std::cout << "Escaneie ou digite o ID do usuário: ";
    inputUser = lerTexto();

    auto userTest = UserId::create(inputUser);

    if (!userTest.has_value()) {
        std::cout << userTest.error().message << std::endl;
        BuscarReservas(serv);
        return;
    }

    auto result = serv.buscarReservas(userTest.value());
    if (!result) {
        std::cout << result.error().message << std::endl;
        system("pause");
        return;
    }
    auto& res = result.value();
    std::cout << "Foram encontrados " << res.size() << " resultados: \n\n";
	const int reserva_size = 1;
	std::vector<std::string> out;
	for (int i = 0; i < res.size(); i++) {
		out.push_back(res[i].nome_livro);
        std::cout << i +1 << ". " << res[i].nome_livro << "\n";
	}
    std::cout << "\n\nO que você deseja fazer?\n" << std::endl;
    std::array<std::string, 2> options = {"Cancelar uma reserva", "Voltar"};
    int select = exibirSelecao(options);
    switch (select) {
    case 0:{
            clearScreen();
            int choice = exibirSelecao("De qual livro é a reserva que você gostaria de cancelar?\n", out, "");
            std::cout << "\n\nTem certeza que gostaria de cancelar a reserva do livro \"" << out[choice] << "\"?\n";
            std::array<std::string, 2> yorn = { "Sim", "Não" };
            int selecionada = exibirSelecao(yorn);
            if (!selecionada) {
                auto cancel = serv.cancelarReserva(res[choice].id_reserva);
                if (!cancel) {
                    std::cout << cancel.error().message << std::endl;

                }
                else {
                    std::cout << "Reserva cancelada com sucesso!" << std::endl;
                }

            }
            system("pause");
            return;
    }
    default:
        return;
    }

}


====================
// ARQUIVO: .\ui\screens\BuscarReservas.h
====================
﻿#pragma once

#include "../../application/LibService.h"

void BuscarReservas(LibService& serv);



====================
// ARQUIVO: .\ui\screens\BuscarUsuario.cpp
====================
#include "BuscarUsuario.h"

#include "../terminal/terminal.h"
#include "../utils/exibirSelecao.h"
#include "../terminal/InputUtils.h"
#include "../../core/UserSearchField.h"
#include "../../core/dto/UserSearchResult.h"
#include "../utils/criarLinha.h"
#include "MostrarUsuario.h"
#include <iostream>
#include <array>

void BuscarUsuario(LibService& serv) {
	clearScreen();
	std::cout << "========== Buscar Usuário ==========" << std::endl;
	std::cout << "Você deseja procurar pelo nome ou ID?\n\n";

	std::array<std::string, 2> opcoes = {
		"ID",
		"Nome"
	};
	int selecionada = exibirSelecao(opcoes);
	std::cout << std::endl;
	std::cout << std::endl;
	std::cout << "Digite a expressão que deseja buscar: ";
	std::string s = lerTexto();
	clearScreen();
	

	ECM::Expected<std::vector<UserSearchResult>> Resultado;
	ECM::Expected<UserId> idTest = std::unexpected(validation("Id não inicializado"));
	switch (selecionada) {
	case 0:
		idTest = UserId::create(s);
		if (!idTest) {
			std::cout << idTest.error().message << std::endl;
			system("pause");
			clearScreen();
			BuscarUsuario(serv);
		}
		else {
			Resultado = serv.buscarUsuarioId(idTest.value());
			break;
		}
	case 1:
		
		Resultado = serv.buscarUsuario(s);
		break;
	}
	if (!Resultado) {
		std::cout << Resultado.error().message << std::endl;
		system("pause");
		return;
	}
	clearScreen();
	auto res = Resultado.value();
	std::cout << "Foram encontrados " << res.size() << " resultados:" << std::endl;
	std::cout << std::endl;
	const int usr_size = 2;
	std::array<int, usr_size> sizes = { 6, 30 };
	std::array<std::string, usr_size> line = {
		"ID",
		"Nome"
	};
	auto labels = criarLinha(line, sizes);
	std::cout << "Resultados da busca: \n\n\n" + labels[0] + "\n" + labels[1] + "\n";
	std::string caput2;
	std::vector<std::string> out;
	for (int i = 0; i < res.size(); i++) {
		auto& usr = res[i];
		std::array<std::string, usr_size> strs = {
			usr.user_id.get_Id_format(),
			usr.nome
		};
		auto linha = criarLinha(strs, sizes);
		out.push_back(linha[0]);
		caput2 = caput2 + linha[0] + "\n" + linha[1] + "\n";
	}
	std::array<std::string, 2> escolha = { "Mostrar detalhes", "Voltar" };
	std::cout << caput2 + "\n\n O que você deseja fazer?\n\n";
	int input = exibirSelecao(escolha);
	int choice;
	switch (input) {
	case 0:
		clearScreen();
		choice = exibirSelecao("Selecione o usuário para mostrar os detalhes?\n\n\n  " + labels[0] + "\n" + labels[1], out, labels[1]);
		MostrarUsuario(serv, res[choice].user_id);
		break;
	default:
		break;
	}
}


====================
// ARQUIVO: .\ui\screens\BuscarUsuario.h
====================
﻿#pragma once

#include "../../application/LibService.h"

void BuscarUsuario(LibService& serv);



====================
// ARQUIVO: .\ui\screens\CadastrarLivro.cpp
====================
﻿#include "CadastrarLivro.h"

#include <iostream>
#include <string>

#include "../terminal/terminal.h"
#include "../terminal/InputUtils.h"
#include "../forms/Form.h"


void cadastrarLivro(LibService& service) {

    Form form("Cadastro de Livro");

    form.add(std::make_unique<Field<BookId>>("ID do livro", BookId::create));

    form.add(std::make_unique<Field<std::string>>(
        "Título",
        [](const std::string& input) -> ECM::Expected<std::string> {
            if (!input.empty()) {
                return input;
            }
            return std::unexpected(validation("Nome não pode ser vazio!"));
        }));

    form.add(std::make_unique<Field<std::string>>(
        "Subtítulo",accept_any));

    form.add(std::make_unique<Field<std::string>>(
        "Autor(es)", accept_any));

    form.add(std::make_unique<Field<std::string>>(
        "Assunto", accept_any));

    form.add(std::make_unique<Field<std::string>>(
        "Coleção", accept_any));

    form.add(std::make_unique<Field<int>>(
        "Número de cópias", int_validator));

    if (!form.run()) return;

    auto idTest = BookId::create(form.get(0));

      Book b(
        idTest.value(),
        form.get(1),
        form.get(2),
        form.get(3),
        form.get(4),
        form.get(5),
        std::stoi(form.get(6))
    );


    auto res = service.cadastrarLivro(b);
    if (res) {
        std::cout << "\nLivro cadastrado com sucesso!\n";
    }
    else {
        std::cout << "\nErro ao cadastrar livro: " << res.error().message << std::endl;
    }

    system("pause");
   
    
}


====================
// ARQUIVO: .\ui\screens\CadastrarLivro.h
====================
﻿#pragma once

#include "../../application/LibService.h"

void cadastrarLivro(LibService& service);



====================
// ARQUIVO: .\ui\screens\CadastrarUsuario.cpp
====================
﻿#include "CadastrarUsuario.h"
#include "../terminal/Terminal.h"
#include "../terminal/InputUtils.h"
#include "../forms/Form.h"

#include "../../core/entities/User.h"

#include <iostream>
#include <expected>


void cadastrarUsuario(LibService& serv) {

    Form form("Cadastro de Usuário");

    form.add(std::make_unique<Field<UserId>>("ID do usuario", UserId::create));

    form.add(std::make_unique<Field<std::string>>(
        "Nome",
        [](const std::string& input) -> ECM::Expected<std::string> {
            if (!input.empty()) {
                return input;
            }
            return std::unexpected(validation("Nome não pode ser vazio!"));
        }));

    form.add(std::make_unique<Field<Email>>("E-mail", Email::create));

    form.add(std::make_unique<Field<std::string>>(
        "Telefone",
        [](const std::string& input) -> ECM::Expected<std::string> {
            if (!input.empty()) {
                return input;
            }
            return std::unexpected(validation("Nome não pode ser vazio!"));
        }
    ));

    if (!form.run()) return;

    auto idTest = UserId::create(form.get(0));
    auto emailTest = Email::create(form.get(2));

    User u(
        idTest.value(),
        form.get(1),
        emailTest.value(),
        form.get(3)
    );

    auto res = serv.salvarUsuario(u);
    if (res) {
        std::cout << "\nUsuário cadastrado com sucesso!\n";
    }
    else {
        std::cout << "\nErro ao cadastrar usuário: " << res.error().message << std::endl;
    }

    system("pause");
}



====================
// ARQUIVO: .\ui\screens\CadastrarUsuario.h
====================
﻿#pragma once

#include "../../application/LibService.h"


void cadastrarUsuario(LibService& serv);



====================
// ARQUIVO: .\ui\screens\MostrarUsuario.cpp
====================
#include "MostrarUsuario.h"
#include "AlterarUsuario.h"
#include "../utils/Print.h"
#include "../utils/exibirSelecao.h"
#include <windows.h>
#include <iostream>

void MostrarUsuario(LibService& serv, UserId& id) {
	clearScreen();
	std::cout << "=========== Detalhes de Usuário ===========\n\n";
	auto u = serv.idToUser(id);
	if (!u) {
		std::cout << u.error().message << std::endl;
	}
	std::string caput = ECM::UserToString(u.value());
	std::array<std::string, 2> escolha = { "Alterar cadastro", "Voltar" };
	std::cout << caput + "\n\n O que você deseja fazer?" << std::endl;
	int input = exibirSelecao(escolha);
	switch (input) {
	case 0:{
		AlterarUsuario(serv, u.value());
		break;
	}
	default:
		return;
	}
	return;
}


====================
// ARQUIVO: .\ui\screens\MostrarUsuario.h
====================
﻿#pragma once

#include "../../application/LibService.h"

void MostrarUsuario(LibService& serv, UserId& id);


====================
// ARQUIVO: .\ui\screens\RegistrarDevolucao.cpp
====================
﻿#include "RegistrarDevolucao.h"

#include "../terminal/Terminal.h"

#include "../input/LoanInput.h"


#include <iostream>

void registrarDevolucao(LibService& serv) {
    clearScreen();
    std::cout << "===== Registrar Devolução =====" << std::endl;

    ECM::Expected<LoanInput> input = lerUserEItem();

    if (!input.has_value()) {
        std::cout << "Devolução cancelada.\n";
        system("pause");
        return;
    }

    LoanInput loan_input = input.value();

    auto result = serv.devolver(loan_input.user, loan_input.item);


    if (!result && (result.error().type != Error::Type::Reserved)) {
        std::cout << result.error().message << std::endl;
    }
    std::cout << "Livro devolvido com sucesso!" << std::endl;
    std::cout << std::endl;
    if (!result && result.error().type == Error::Type::Reserved) {
        std::cout << result.error().message << std::endl;
    }
    system("pause");
    return;
}





====================
// ARQUIVO: .\ui\screens\RegistrarDevolucao.h
====================
﻿#pragma once

#include "../../application/LibService.h"

void registrarDevolucao(LibService& serv);



====================
// ARQUIVO: .\ui\screens\RegistrarEmprestimo.cpp
====================
﻿#include "RegistrarEmprestimo.h"

#include "../terminal/Terminal.h"

#include <string>
#include <expected>
#include <chrono>

#include <iostream>

#include "../../core/ids/UserId.h"
#include "../../core/ids/ItemId.h"

#include "../../core/entities/Loan.h"


#include "../../core/utils/TimeUtils.h"

#include "../input/LoanInput.h"

void registrarEmprestimo(LibService& serv) {
    clearScreen();
    std::cout << "========== Registrar Novo Empréstimo ==========\n\n";

    ECM::Expected<LoanInput> input = lerUserEItem();

    if (!input.has_value()) {
        std::cout << "ERRO! Empréstimo cancelado.\n";
        system("pause");
        return;
    }

    LoanInput loan_input = input.value();

    auto result = serv.emprestar(loan_input.user, loan_input.item);

    if (!result.has_value()) {
        std::cout << std::endl;
        std::cout << result.error().message << std::endl;
        system("pause");
        return;
    }
        std::cout << std::endl;
        std::cout << std::endl;
        std::cout << "Empréstimo registrado com sucesso!" << std::endl;
        std::cout << "A data de devolução é " << timeToStringUser(result.value().due_at) << "." << std::endl; 
        system("pause");
}


====================
// ARQUIVO: .\ui\screens\RegistrarEmprestimo.h
====================
﻿#pragma once

#include "../../application/LibService.h"


void registrarEmprestimo(LibService& serv);



====================
// ARQUIVO: .\ui\screens\renovacao.cpp
====================
﻿#include "renovacao.h"

#include "../terminal/Terminal.h"

#include "../input/LoanInput.h"

#include "../../core/utils/TimeUtils.h"

#include <iostream>

void renovacao(LibService& serv) {
    clearScreen();
    std::cout << "===== Renovar um Empréstimo Ativo =====" << std::endl;

    ECM::Expected<LoanInput> input = lerUserEItem();

    if (!input.has_value()) {
        std::cout << "Empréstimo cancelado.\n";
        system("pause");
        return;
    }

    LoanInput loan_input = input.value();

    auto result = serv.renovar(loan_input.user, loan_input.item);

    if (!result) {
        std::cout << result.error().message << std::endl;
    }
    std::cout << "Livro renovado com sucesso!" << std::endl;
    system("pause");
    return;

}


====================
// ARQUIVO: .\ui\screens\renovacao.h
====================
﻿#pragma once

#include "../../application/LibService.h"

void renovacao(LibService& serv);



====================
// ARQUIVO: .\ui\screens\Reservar.cpp
====================
﻿#include "Reservar.h"
#include "../terminal/InputUtils.h"
#include "../../core/utils/TimeUtils.h"
#include <iostream>
#include "windows.h"

void Reservar(LibService& serv, const BookId& book) {
    std::string inputUser;
    std::string inputItem;
    std::cout << "Escaneie ou digite o ID do usuário: ";
    inputUser = lerTexto();
    // atualmente a função de prever disponbilidade apenas é mostrada na tela após a reserva ter sido efetivada
    // (nesse arquivo, ali embaixo), mas como o cálculo da previsão depende de quantas reservas tem e, como 
    // futuramente pode ser interessante  mostrar a previsão sem ter feito reserva, em outra tela, atualmente
    // o cálculo da previsão é implementado tomando como base que a reserva não foi feita ainda, por isso 
    // a função precisa ser chamada aqui em cima
    auto dataTest = serv.preverDisponibilidade(book); 
    if (!dataTest && (dataTest.error().type == Error::Type::Conflict)) {
        std::cout << dataTest.error().message << std::endl;
        std::cout << std::endl;
        system("pause");
        return;
    }
    auto userTest = UserId::create(inputUser);

    if (!userTest.has_value()) {
        std::cout << userTest.error().message << std::endl;
        Reservar(serv, book);
        return;
    }
    std::cout << std::endl;
    auto res = serv.reservar(userTest.value(), book);
    if (!res) {
        std::cout << res.error().message << std::endl;

    }
    else {
        std::cout << "Reserva efetivada com sucesso!" << std::endl;
        
        if (!dataTest) {
            std::cout << dataTest.error().message << std::endl;
        }
        else {
            std::cout << "A data prevista em que o livro se encontrará disponível é: " << timeToStringUser(dataTest.value()) << std::endl;
        }
    }
    std::cout << std::endl;
        system("pause");
        return;
}


====================
// ARQUIVO: .\ui\screens\Reservar.h
====================
﻿#pragma once

#include "../../core/entities/Book.h"
#include "../../application/LibService.h"

void Reservar(LibService& serv, const BookId& book);



====================
// ARQUIVO: .\ui\terminal\configurarTerminal.cpp
====================
﻿#include <windows.h>
#include "terminal.h"

void configurarTerminal() {
    // ----- lida com caracteres especiais no input e output
    SetConsoleOutputCP(65001);
    SetConsoleCP(65001);
    // ----- evita quebra de linhas
    enableHorizontalScroll(150, 2000);
    // ----- ativa expressões de controle
    enableANSI();
}


====================
// ARQUIVO: .\ui\terminal\configurarTerminal.h
====================
﻿#pragma once

void configurarTerminal();



====================
// ARQUIVO: .\ui\terminal\InputUtils.cpp
====================
﻿#include "InputUtils.h"
#include <iostream>


#ifdef _WIN32
#include <windows.h>
#endif

std::string lerTexto() {
#ifdef _WIN32
    // 1. Prepara um buffer para ler caracteres largos (UTF-16)
    const int BUFFER_SIZE = 2048;
    wchar_t wBuffer[BUFFER_SIZE];
    DWORD charsRead = 0;
    HANDLE hInput = GetStdHandle(STD_INPUT_HANDLE);

    // 2. Lê diretamente do console do Windows (evita o bug do std::cin)
    if (!ReadConsoleW(hInput, wBuffer, BUFFER_SIZE - 1, &charsRead, NULL)) {
        return "";
    }

    // 3. Remove o "Enter" (\r\n) que vem junto
    // Verifica se leu algo e remove os ultimos caracteres se forem quebra de linha
    if (charsRead >= 2 && wBuffer[charsRead - 2] == L'\r') {
        wBuffer[charsRead - 2] = L'\0';
    }
    else if (charsRead > 0 && (wBuffer[charsRead - 1] == L'\n' || wBuffer[charsRead - 1] == L'\r')) {
        wBuffer[charsRead - 1] = L'\0';
    }
    else {
        wBuffer[charsRead] = L'\0';
    }

    // 4. Converte de UTF-16 (Windows) para UTF-8 (SQLite/C++)
    // Primeiro descobre o tamanho necessário
    int size_needed = WideCharToMultiByte(CP_UTF8, 0, wBuffer, -1, NULL, 0, NULL, NULL);

    // Cria a string do tamanho certo
    std::string strTo(size_needed - 1, 0); // -1 por causa do terminador nulo

    // Faz a conversão real
    WideCharToMultiByte(CP_UTF8, 0, wBuffer, -1, &strTo[0], size_needed, NULL, NULL);

    return strTo;
#else
    // Versão simples para Linux/Mac
    std::string line;
    std::getline(std::cin, line);
    return line;
#endif
}


====================
// ARQUIVO: .\ui\terminal\InputUtils.h
====================
﻿#pragma once
#include <string>

std::string lerTexto();



====================
// ARQUIVO: .\ui\terminal\terminal.cpp
====================
﻿#include "terminal.h"
#include <iostream>



#ifdef _WIN32
#include <windows.h>
#include <conio.h>
#endif

void enableANSI() {
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD mode = 0;
    if (GetConsoleMode(hOut, &mode)) {
        mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
        SetConsoleMode(hOut, mode);
    }
}

void clearScreen() {
        HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(hOut, &csbi);

        DWORD cellCount = csbi.dwSize.X * csbi.dwSize.Y;
        DWORD written;

        // Preenche tudo com espaço
        FillConsoleOutputCharacter(hOut, ' ', cellCount, { 0,0 }, &written);

        // Reseta atributos (cores)
        FillConsoleOutputAttribute(hOut, csbi.wAttributes, cellCount, { 0,0 }, &written);

        // Volta o cursor pro topo
        SetConsoleCursorPosition(hOut, { 0,0 });
}


void clearFromPosition(HANDLE hOut, CONSOLE_SCREEN_BUFFER_INFO csbi) {
    
    COORD start = csbi.dwCursorPosition;

    DWORD cellCount =
        (csbi.dwSize.X * csbi.dwSize.Y)
        - (start.Y * csbi.dwSize.X + start.X);

    DWORD written;

    FillConsoleOutputCharacter(hOut, ' ', cellCount, start, &written);
    FillConsoleOutputAttribute(hOut, csbi.wAttributes, cellCount, start, &written);

    SetConsoleCursorPosition(hOut, start);
}

void enableHorizontalScroll(int bufferWidth, int bufferHeight)
{
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    CONSOLE_SCREEN_BUFFER_INFO info;
    GetConsoleScreenBufferInfo(hOut, &info);

    COORD newSize;
    newSize.X = bufferWidth;
    newSize.Y = bufferHeight;

    SetConsoleScreenBufferSize(hOut, newSize);

    SMALL_RECT windowSize;
    windowSize.Left = 0;
    windowSize.Top = 0;
    windowSize.Right = min((SHORT)(bufferWidth - 1), info.srWindow.Right);
    windowSize.Bottom = info.srWindow.Bottom;

    SetConsoleWindowInfo(hOut, TRUE, &windowSize);
}


====================
// ARQUIVO: .\ui\terminal\terminal.h
====================
﻿#pragma once

#ifdef _WIN32
#include <windows.h>
#include <conio.h>
#endif

void clearFromPosition(HANDLE hOut, CONSOLE_SCREEN_BUFFER_INFO csbi);
void enableANSI();
void clearScreen();
void enableHorizontalScroll(int bufferWidth, int bufferHeight);


====================
// ARQUIVO: .\ui\utils\criarLinha.h
====================
﻿#pragma once

#include "strings.h"
#include "../../core/dto/BookSearchResult.h"
#include <array>



template <std::size_t N>
std::array<std::string, 2> criarLinha(std::array<std::string, N> strs, std::array<int, N> sizes) {
	std::array<int, N> dif;
	for (int i = 0; i < N; i++) {
		dif[i] = sizes[i] - static_cast<int>(visualLength(strs[i]));
	}
	std::string out;
	int total = 0;
	for (int i = 0; i < N; i++) {
		out += strToPrint(strs[i], dif[i]) + "|";
		total += static_cast<int>(sizes[i]);
	}
	total = total + N-1;
	std::string line = std::string(total, '-');
	return { out,line };
}




====================
// ARQUIVO: .\ui\utils\exibirSelecao.cpp
====================
#include "exibirSelecao.h"



int exibirSelecao(std::string_view caput, const std::vector<std::string>& opcoes, std::string_view bar) {
    int selecionada = 0;
    while (true) {
        clearScreen();
        std::cout << caput << std::endl;

        for (int i = 0; i < opcoes.size(); i++) {
            if (i == selecionada)
                std::cout << "\033[47;30m> " << opcoes[i] << " \033[0m\n" << bar << "\n";
            else
                std::cout << "  " << opcoes[i] << "\n" << bar << "\n";
        }

        int ch = _getch();
        if (ch == 224) {
            ch = _getch();
            if (ch == 72 && selecionada > 0) selecionada--;
            if (ch == 80 && selecionada < opcoes.size() - 1) selecionada++;
        }
        else if (ch == 13) {
            return selecionada;
        }
    }
}


====================
// ARQUIVO: .\ui\utils\exibirSelecao.h
====================
#pragma once

#include <vector>
#include <array>
#include <string>

#include "../terminal/terminal.h"
#include <iostream>



int exibirSelecao(std::string_view caput, const std::vector<std::string>& opcoes, std::string_view bar);

template <std::size_t N>
int exibirSelecao(std::array<std::string, N>& opcoes) {
    int selecionada = 0;
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hOut, &csbi);
    while (true) {
        clearFromPosition(hOut, csbi);

        for (int i = 0; i < opcoes.size(); i++) {
            if (i == selecionada)
                std::cout << "\033[47;30m> " << opcoes[i] << " \033[0m\n";
            else
                std::cout << "  " << opcoes[i] << "\n";
        }

        int ch = _getch();
        if (ch == 0 || ch == 224) {
            ch = _getch();
            if (ch == 72 && selecionada > 0) selecionada--;
            if (ch == 80 && selecionada < opcoes.size() - 1) selecionada++;
            if (ch == 59) {
                return -1;
            }
        }
        else if (ch == 13) {
            return selecionada;
        }
    }
}

template <std::size_t N>
int exibirSelecao(const std::string_view& caput, std::array<std::string, N>& opcoes) {
    int selecionada = 0;

    while (true) {
        clearScreen();
        std::cout << caput << '\n' << std::endl;

        for (int i = 0; i < opcoes.size(); i++) {
            if (i == selecionada)
                std::cout << "\033[47;30m> " << opcoes[i] << " \033[0m\n";
            else
                std::cout << "  " << opcoes[i] << "\n";
        }

        int ch = _getch();
        if (ch == 0 || ch == 224) {
            ch = _getch();
            if (ch == 72 && selecionada > 0) selecionada--;
            if (ch == 80 && selecionada < opcoes.size() - 1) selecionada++;
            if (ch == 59) {
                return -1;
            }
        }
        else if (ch == 13) {
            return selecionada;
        }
    }
}



====================
// ARQUIVO: .\ui\utils\Print.h
====================
﻿#pragma once
#include "../../core/entities/User.h"
#include "../../core/utils/TimeUtils.h"
#include <iostream>

namespace ECM {
	inline void Print(User& u) {
		std::cout << "ID: " << u.id.get_Id_format() << "\n";
		std::cout << "Nome: " << u.nome << "\n";
		std::cout << "E-mail: " << u.email.get() << "\n";
		std::cout << "Telefone: " << u.tel << "\n";
		if (u.status == UserStatus::Inativo) {
			std::cout << "Status: " << "Inativo" << "\n";
		}
		else if (u.status == UserStatus::Bloqueado) {
			std::cout << "Status: " << "Bloqueado" << "\n";
			if (u.blocked_until == std::nullopt) {
				std::cout << "Sem data de desbloqueio" << std::endl;
			}
			else {
				std::cout << "Bloqueado até: " << timeToStringUser(u.blocked_until.value()) << std::endl;
			}
		}
		else {
			std::cout << "Status: " << "Ativo" << "\n";
		}
		std::cout << std::endl;
		return;
	}

	inline std::string UserToString(User& u) {
		std::string s = "ID: " + u.id.get_Id_format() + "\n";
		s += "Nome: " + u.nome + "\n";
		s+= "E-mail: " + u.email.get() + "\n";
		s += "Telefone: " + u.tel + "\n";
		if (u.status == UserStatus::Inativo) {
			s += "Status: Inativo\n";
		}
		else if (u.status == UserStatus::Bloqueado) {
			s += "Status: Bloqueado\n";
			if (u.blocked_until == std::nullopt) {
				s += "Sem data de desbloqueio\n";
			}
			else {
				s += "Bloqueado até: " + timeToStringUser(u.blocked_until.value()) + "\n";
			}
		}
		else {
			s += "Status: Ativo\n";
		}
		return s;
	}
}



====================
// ARQUIVO: .\ui\utils\strings.cpp
====================
﻿#include "strings.h"
#include <windows.h>

 int visualLength(const std::string& s) {
	if (s.empty()) return 0;

	int wlen = MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, nullptr, 0);
	if (wlen == 0) return s.size();

	std::wstring ws(wlen, L'\0');
	MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, ws.data(), wlen);

	return static_cast<int>(ws.length() - 1); // tira o \0
}

 std::wstring utf8_to_wstring(const std::string& s) {
	if (s.empty()) return L"";

	int len = MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, nullptr, 0);
	std::wstring ws(len, L'\0');
	MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, ws.data(), len);
	ws.pop_back(); // remove \0
	return ws;
}

 std::string wstring_to_utf8(const std::wstring& ws) {
	if (ws.empty()) return "";

	int len = WideCharToMultiByte(CP_UTF8, 0, ws.c_str(), -1, nullptr, 0, nullptr, nullptr);
	std::string s(len, '\0');
	WideCharToMultiByte(CP_UTF8, 0, ws.c_str(), -1, s.data(), len, nullptr, nullptr);
	s.pop_back(); // remove \0
	return s;
}

 std::string utf8_substr(const std::string& s, size_t max_chars) {
	auto ws = utf8_to_wstring(s);

	if (ws.size() <= max_chars)
		return s;

	auto cut = ws.substr(0, max_chars);
	return wstring_to_utf8(cut);
}


 std::string strToPrint(std::string s, int size) {
	if (size >= 0) {
		return s + std::string((size_t)size, ' ');
	}
	else {
		int limit = visualLength(s) + size - 3;
		return utf8_substr(s, limit) + "...";
	}
}


====================
// ARQUIVO: .\ui\utils\strings.h
====================
﻿#pragma once

#include <string>

int visualLength(const std::string& s);

std::wstring utf8_to_wstring(const std::string& s);

std::string wstring_to_utf8(const std::wstring& ws);

std::string utf8_substr(const std::string& s, size_t max_chars);

std::string strToPrint(std::string s, int size);


